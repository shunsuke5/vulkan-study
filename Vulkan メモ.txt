・全ての機能はインスタンスを介して利用する。

・Vulkan-Hppでは、破棄処理の必要なほぼすべてのオブジェクト型について
　vk::Uniquexxx のような対応する型があり、またそれに対応した
　createxxxUniqueのような関数が存在する。destroy()メソッドで明示的に
　破棄しなくてよくなるため、積極的に使用した方が良い。

・vk::InstanceCreateInfo という構造体に色々な情報を乗せることで、
　Vulkanの拡張機能をオンにしたり、デバッグ情報を表示させるといったことができる。

・物理デバイスはvk::PhysicalDevice型で表される。

・GPUの能力を使うような機構は、全て論理デバイスを通して利用する。
　物理デバイスを直接いじることはできない。

・レイヤーという機能があり、vulkanのAPIを呼んだ際の処理に
　様々な追加処理を入れることができる。

　その中の1つにバリデーションレイヤーがある。
　これを使うとデバッグに非常に役立つ。以下のように指定して使用する。

    auto requiredLayres = { "VK_LAYER_KHRONOS_validation" };

https://chaosplant.tech/do/vulkan/ex1/

・Vulkanにおけるキューとは、GPUの実行するコマンドを保持する待ち行列のこと。
　GPUにコマンドを送るときは、このキューにコマンドを詰め込むことになる。
　1つのGPUが持っているキューは1つだけとは限らず、いくつも持っている場合がある。
　また、キューによってサポートしている機能としていない機能があったりするため、
　キューにコマンドを送るときは、そのキューが何の機能をサポートしているかを
　事前に把握しておく必要がある。

　キューファミリとは、同じ能力を持っているキューをひとまとめにしたもの。
　1つの物理デバイスには1個以上のキューファミリがあり、
　1つのキューファミリには1個以上の同等の機能を持ったキューが所属する。

・論理デバイスからキューを取得する時、論理デバイスにあらかじめ
　使用するキューを伝えておく必要がある。vk::DeviceCreateInfo構造体に
　vk::DeviceQueueCreateInfo構造体の配列を指定して、
　「この論理デバイスを通じてこのキューファミリからいくつのキューを使う」
　といった情報を指定する必要があるのである。
　(サイトで実行時エラーになるべきところでエラーにならなかったので、
　バージョンが変わって挙動が変わったのだろうか？)

・キューはdestroyする必要が無いため、uniqueもない。

・GPUにコマンドを送るときはキューにコマンドを詰め込むと記載があったが、
　より正確には「コマンドバッファの中にコマンドを記録し、そのコマンドバッファを
　キューに送る」という手続きをとる。そのため、コマンドを送信する際には
　必ずコマンドバッファが必要になる。

　コマンドバッファを作るには、前段階として「コマンドプール」という
　別のオブジェクトを作る必要がある。コマンドバッファをコマンドの記録に使う
　オブジェクトとするならば、コマンドプールはコマンドを記録するための
　メモリ実体のようなものである。コマンドバッファを作る際には必ず必要になる。

・vk::Queue#submit()でGPUに命令を送ることができるが、あくまで「送る」だけなので
　submit()から処理が返ってきた段階で送った命令が完了されているとは限らない。
　実用的なプログラムを作るためには「依頼した処理が終わるまで待つ」
　方法を知る必要がある。これに必要なのが「セマフォ」や「フェンス」という機構である。

　GPUに投げた処理は基本的に非同期処理になる。そのため、レンダリングなどの処理を
　GPUに投げた場合、状況に応じて処理の完了を待つ必要がある。
　このための機構がセマフォ、フェンスである。これらの機構を適切に利用することで、
　処理の順序関係がおかしくならないで済む。

　この2つの主な違いは、フェンスがホスト側(CPU側)で待機するための機構であることに対し、
　セマフォは主にGPU内で他の処理を待機するための機構であることである。

　フェンスオブジェクトは内部的にシグナル状態と非シグナル状態の
　2状態を持っている。初期状態(あるいはリセット直後の状態)は非シグナル状態である。
　様々な処理に対して「この処理が終わったらこのフェンスをシグナル状態にする」
　といった設定ができ、GPUを利用するほとんどの関数は引数としてフェンスを渡せる。
　例として、キューのsubmit()メソッドの第二引数などでフェンスを渡すことができる。
　2つの状態は非シグナル状態が赤信号、シグナル状態が青信号のようなものである。

　セマフォもフェンスと同じく、シグナル状態と非シグナル状態の2つがあり、
　シグナル状態にいなるまで待機することができる。
　フェンスと違い、特定の処理の完了に引っ掛けるには構造体に指定することが多い。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　signalSemaphoreCount,pSignalSemaphores を用いる。
　ここに指定すると、送信したコマンドの処理が完了したときに指定した
　セマフォがシグナル状態になる。

　また、待機のために指定する場合も構造体に指定する。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　waitSemaphoreCount,pWaitSemaphores,pWaitDstStageMask で
　待機するセマフォを指定する。
　pWaitDstStageMaskは、パイプラインのどの時点で待機するかを指定する。
　単純に処理の開始時点で待機するということもできるが、
　例えばフラグメントシェーダでだけ特定の処理の結果を待つ必要があるならば、
　「フラグメントシェーダの処理が始まるまで待機」ということにして
　頂点シェーダの処理などはシグナル状態を待たずに始める、といったこともできる。
　GPUの並列化能力に余裕がある場合はこのようにして、
　必要最低限の部分でだけ処理待ちをする方が効率が上がるわけである。

　セマフォはフェンスと違い、明示的にリセットする必要はない。
　そのセマフォのシグナル状態を待っていた処理が開始すると、自動でリセットされる。
　こうした動作をするため、ある1つの処理に複数の他の処理が依存するという場合は
　その数だけセマフォが必要となる。

　1つのセマフォのシグナルを複数の処理で待つことは一般的ではないため、
　フェンスのように信号機に例えて考えるのは適切ではないと思われる。
　セマフォとは「ある1つの処理の完了」と「ある1つの処理の開始」の
　順序関係の取り決めであり、1対1の関係を表す。

　同期のための機構は他にもパイプラインバリア、イベント、レンダーパスなど
　様々なものがある。その中でもフェンスとセマフォが最も基本的でわかりやすく、
　また使う機会も多いため最初に覚えておくとよい。
https://chaosplant.tech/do/vulkan/ex2/

・タイムラインセマフォという数値カウンターを持つ特殊で高機能なセマフォもあるが、
　Vulkanでは2状態のバイナリセマフォの方が基本的である。

・表示する先の画面は「サーフェス」というオブジェクトで抽象化される。
　ウィンドウやスクリーンなど、表示する先として使える何かは全て
　サーフェスと言う同じ種類のオブジェクトで表され、統一的に扱うことができる。
　このような仕組みのため、「どこに表示しようとしているのか」を気にする必要が無い。
　サーフェスさえ取得すればあとは同じ処理で描画、表示ができるのである。

　しかし、サーフェスを作成する部分の処理はプラットフォーム依存になる。
　サーフェスは表示先を表すオブジェクトだが、具体的な表示先が何を表すのかは
　プラットフォーム次第だからである。Windowsであればウィンドウ、Androidであればアプリ、など。
　そのため、WindowsであればWindows専用のAPIでウィンドウ情報からサーフェスを作成する必要があり、
　AndroidであればAndroid専用のAPIでアプリ情報からサーフェスを作成しなければならない。

　そこで、そうしたプラットフォーム依存な部分を覆い隠してくれる便利な外部ライブラリを使用することで、
　効率的に開発を進めることができる。GLFW,SDLなどがある。

・画像はvk::Imageと言うオブジェクトで表される。
　これはvk::DeviceのCreateImage()で作成できる。

・画像オブジェクトを扱うためには、イメージにメモリを確保して割り当てる必要がある。
　ここで言うメモリはnew,mallocで確保できる通常のメモリとは違い、
　デバイスメモリという特殊なメモリであることに注意する。
　通常のメモリはGPUからアクセスすることができないため、
　GPUからアクセスできる特殊なメモリを用意する必要があり、それがデバイスメモリである。

　new,mallocなどで確保する通常のメモリとデバイスメモリの重要な違いとして、
　デバイスメモリには「種類」がある。デバイスメモリを使う際はどれを使うか適切に選ばなければならない。
　どんな種類のデバイスメモリがあるかは物理デバイス依存である。

・メモリを確保する時はvk::MemoryAllocateInfoに必要なメモリのサイズと種類を指定する。

・描画をするにあたり、まずレンダーパスというものが必要になる。
　レンダーパスとは、一言で言えば描画の処理順序を記述したオブジェクトであり、
　描画処理の際には必ず必要になる。
　おおざっぱな計画書みたいなものであり、コマンド(具体的な作業手順)とは別物。

　レンダーパスの情報を構成するものは以下の3つがある。

アタッチメント
　→ レンダーパスにおいて描画処理の対象となる画像データのこと。

サブパス
　→ 1つの描画処理。単一または複数のサブパスが集まってレンダーパス全体を構成する。
　　サブパスは任意の個数のアタッチメントを入力として受け取り、任意の個数のアタッチメントに描画処理を出力する。

サブパス依存性
　→ サブパス間の依存関係。
　　つまり「サブパス1番が終わってからでないとサブパス2番は実行できない」などの関係を表す。

　レンダーパスはあくまで「この処理はこのデータを相手に、あの処理はあのデータを...」
　といった関係性を表す「枠組み」に過ぎないため、それぞれの処理(サブパス)が具体的に
　どのような処理を行うかは関知しない。

・パイプラインとは、3DCGの基本的な描画処理をひとつながりにまとめたものである。
　ほぼすべての3DCGは三角形の集まりであり、我々が最初に持っているものは
　三角形の各店の色や座標だが、最終的に欲しいものは画面のどのピクセルが
　どんな色なのかという情報である。この間をつなぐ演算処理は大体お決まりのパターンになっており、
　まとめてグラフィックスパイプラインというものになっている。

　そしてこの処理は全ての部分が固定されているのではなく、
　プログラマ側で色々なカスタムを指定する部分があり、それらの情報をまとめたものが
　「パイプラインオブジェクト」である。

　パイプラインオブジェクトを使用して描画処理を行う際には
　コマンドでパイプラインオブジェクトを指定し、ドローコールを呼ぶ。

　vulkanではグラフィックスパイプラインとコンピュートパイプラインの2種類がある。
　コンピュートパイプラインはGPGPUなどに使用する。
　普通に描画を行う際は、グラフィックスパイプラインを作成する。

・シェーダはパイプラインの中の主役と言っても過言ではないくらいになんでもできる。
　パイプラインとは「点の集まりでできた図形を色のついたピクセルの集合に変換するもの」で、
　シェーダはそのパイプラインの中において、あの点とこの点をあっちに動かしたりこっちに動かしたり、
　あのピクセルやこのピクセルを赤に塗ったり青に塗ったりする役割を果たす。

　昔はシェーダも簡素なことしかせず、文字通りただ「陰影をつけるもの」であり、
　処理内容もほぼ固定だったらしいが、今では自由にシェーダプログラムを書いて
　GPUに実行させることができる。空間を捻じ曲げ、複雑な模様を描き、
　モノや何かをべらぼうに増やすことさえもできる。

　しかし、何でもできるようになった代わりに、お決まりのような普通の処理しかしたくない場合でも
　それをちゃんと書かなければならず、デフォルト動作に任せる選択肢が存在しないのである。

　シェーダを使用するには、シェーダプログラムを書く必要がある。
　GLSLというC言語をベースとした専用言語を使用する。
　GLSLで書いたプログラムは、専用のソフトでSPIR-Vという中間言語にコンパイルし、
　Vulkanからはそれを読み込んで実行することになる。
　ちなみに、SPIR-Vの仕様はGLSLとは独立しており、実際にはGLSL以外の言語、
　例えばDirectXで使われるHLSLなどからもコンパイルすることが可能である。

・シェーダには種類がある。その中で最低限必要なものとして、
　頂点シェーダ(バーテックスシェーダ)、フラグメントシェーダを作成する。

　頂点シェーダは頂点1つごとに1回呼ばれ、その頂点の座標を出力する。

　フラグメントシェーダはピクセル1つごとに呼ばれ、そのピクセルの色を決定する。
　色はRGBA(RGBとαチャンネル)の4次元ベクトルで表現され、
　それぞれの値は0.0～1.0の実数で表現される。

・Vulkanでは画像の左上が(-1.0, -1.0)、右下が(1.0, 1.0)になる。
　つまり、半分の位置は0.0となる。

・GLSLをコンパイルするには、Vulkan SDKに付属のglslcというツールを使う。
　binディレクトリにあるため、パスを通すなどしてコマンドを使用できるようにする。

・

======================================================================

・環境構築

　WSLでvulkan SDK,vcpkg,CMakeを使用して学習を進める形に変更
　vulkan SDKとvcpkgはインストール済み
　なんかvulkanSDKとvcpkgのダウンロード、
　~/.bashrc, ~/.profileへの環境変数追加の記述、
　あとは参考サイトの1.4の環境構築と同じファイルを作成、
　同じ手順でやったらできた。
　なぜ実家のPCではエラーが起きたのだろうか？
　違うことと言えば、C:\VulkanSDK\1.4.321.1\Bin を
　システム環境変数に追加してることぐらいだが。

　vcpkgはvs2022に付属していたものを使用、
　vulkan SDKは公式サイトからダウンロード
　手順は2つ目のサイトを参考、include,libディレクトリパスの追加と
　vulkan1-lib のようなファイルの追加はどのライブラリを使用するにしても
　必要そうな手順なので、覚えておくと良いかもしれない。
https://docs.vulkan.org/tutorial/latest/02_Development_environment.html
https://chaosplant.tech/do/vulkan/1-4/

・以下サイトを参考に進めていく
https://chaosplant.tech/do/vulkan/