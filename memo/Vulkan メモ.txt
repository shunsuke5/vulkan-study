・全ての機能はインスタンスを介して利用する。

・Vulkan-Hppでは、破棄処理の必要なほぼすべてのオブジェクト型について
　vk::Uniquexxx のような対応する型があり、またそれに対応した
　createxxxUniqueのような関数が存在する。destroy()メソッドで明示的に
　破棄しなくてよくなるため、積極的に使用した方が良い。

・vk::InstanceCreateInfo という構造体に色々な情報を乗せることで、
　Vulkanの拡張機能をオンにしたり、デバッグ情報を表示させるといったことができる。

・物理デバイスはvk::PhysicalDevice型で表される。

・GPUの能力を使うような機構は、全て論理デバイスを通して利用する。
　物理デバイスを直接いじることはできない。

・レイヤーという機能があり、vulkanのAPIを呼んだ際の処理に
　様々な追加処理を入れることができる。

　その中の1つにバリデーションレイヤーがある。
　これを使うとデバッグに非常に役立つ。以下のように指定して使用する。

    auto requiredLayres = { "VK_LAYER_KHRONOS_validation" };

https://chaosplant.tech/do/vulkan/ex1/

・Vulkanにおけるキューとは、GPUの実行するコマンドを保持する待ち行列のこと。
　GPUにコマンドを送るときは、このキューにコマンドを詰め込むことになる。
　1つのGPUが持っているキューは1つだけとは限らず、いくつも持っている場合がある。
　また、キューによってサポートしている機能としていない機能があったりするため、
　キューにコマンドを送るときは、そのキューが何の機能をサポートしているかを
　事前に把握しておく必要がある。

　キューファミリとは、同じ能力を持っているキューをひとまとめにしたもの。
　1つの物理デバイスには1個以上のキューファミリがあり、
　1つのキューファミリには1個以上の同等の機能を持ったキューが所属する。

・論理デバイスからキューを取得する時、論理デバイスにあらかじめ
　使用するキューを伝えておく必要がある。vk::DeviceCreateInfo構造体に
　vk::DeviceQueueCreateInfo構造体の配列を指定して、
　「この論理デバイスを通じてこのキューファミリからいくつのキューを使う」
　といった情報を指定する必要があるのである。
　(サイトで実行時エラーになるべきところでエラーにならなかったので、
　バージョンが変わって挙動が変わったのだろうか？)

・キューはdestroyする必要が無いため、uniqueもない。

・GPUにコマンドを送るときはキューにコマンドを詰め込むと記載があったが、
　より正確には「コマンドバッファの中にコマンドを記録し、そのコマンドバッファを
　キューに送る」という手続きをとる。そのため、コマンドを送信する際には
　必ずコマンドバッファが必要になる。

　コマンドバッファを作るには、前段階として「コマンドプール」という
　別のオブジェクトを作る必要がある。コマンドバッファをコマンドの記録に使う
　オブジェクトとするならば、コマンドプールはコマンドを記録するための
　メモリ実体のようなものである。コマンドバッファを作る際には必ず必要になる。

・vk::Queue#submit()でGPUに命令を送ることができるが、あくまで「送る」だけなので
　submit()から処理が返ってきた段階で送った命令が完了されているとは限らない。
　実用的なプログラムを作るためには「依頼した処理が終わるまで待つ」
　方法を知る必要がある。これに必要なのが「セマフォ」や「フェンス」という機構である。

　GPUに投げた処理は基本的に非同期処理になる。そのため、レンダリングなどの処理を
　GPUに投げた場合、状況に応じて処理の完了を待つ必要がある。
　このための機構がセマフォ、フェンスである。これらの機構を適切に利用することで、
　処理の順序関係がおかしくならないで済む。

　この2つの主な違いは、フェンスがホスト側(CPU側)で待機するための機構であることに対し、
　セマフォは主にGPU内で他の処理を待機するための機構であることである。

　フェンスオブジェクトは内部的にシグナル状態と非シグナル状態の
　2状態を持っている。初期状態(あるいはリセット直後の状態)は非シグナル状態である。
　様々な処理に対して「この処理が終わったらこのフェンスをシグナル状態にする」
　といった設定ができ、GPUを利用するほとんどの関数は引数としてフェンスを渡せる。
　例として、キューのsubmit()メソッドの第二引数などでフェンスを渡すことができる。
　2つの状態は非シグナル状態が赤信号、シグナル状態が青信号のようなものである。

　セマフォもフェンスと同じく、シグナル状態と非シグナル状態の2つがあり、
　シグナル状態にいなるまで待機することができる。
　フェンスと違い、特定の処理の完了に引っ掛けるには構造体に指定することが多い。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　signalSemaphoreCount,pSignalSemaphores を用いる。
　ここに指定すると、送信したコマンドの処理が完了したときに指定した
　セマフォがシグナル状態になる。

　また、待機のために指定する場合も構造体に指定する。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　waitSemaphoreCount,pWaitSemaphores,pWaitDstStageMask で
　待機するセマフォを指定する。
　pWaitDstStageMaskは、パイプラインのどの時点で待機するかを指定する。
　単純に処理の開始時点で待機するということもできるが、
　例えばフラグメントシェーダでだけ特定の処理の結果を待つ必要があるならば、
　「フラグメントシェーダの処理が始まるまで待機」ということにして
　頂点シェーダの処理などはシグナル状態を待たずに始める、といったこともできる。
　GPUの並列化能力に余裕がある場合はこのようにして、
　必要最低限の部分でだけ処理待ちをする方が効率が上がるわけである。

　セマフォはフェンスと違い、明示的にリセットする必要はない。
　そのセマフォのシグナル状態を待っていた処理が開始すると、自動でリセットされる。
　こうした動作をするため、ある1つの処理に複数の他の処理が依存するという場合は
　その数だけセマフォが必要となる。

　1つのセマフォのシグナルを複数の処理で待つことは一般的ではないため、
　フェンスのように信号機に例えて考えるのは適切ではないと思われる。
　セマフォとは「ある1つの処理の完了」と「ある1つの処理の開始」の
　順序関係の取り決めであり、1対1の関係を表す。

　同期のための機構は他にもパイプラインバリア、イベント、レンダーパスなど
　様々なものがある。その中でもフェンスとセマフォが最も基本的でわかりやすく、
　また使う機会も多いため最初に覚えておくとよい。
https://chaosplant.tech/do/vulkan/ex2/

・タイムラインセマフォという数値カウンターを持つ特殊で高機能なセマフォもあるが、
　Vulkanでは2状態のバイナリセマフォの方が基本的である。

・画像はvk::Imageと言うオブジェクトで表される。
　これはvk::DeviceのCreateImage()で作成できる。

・画像オブジェクトを扱うためには、イメージにメモリを確保して割り当てる必要がある。
　ここで言うメモリはnew,mallocで確保できる通常のメモリとは違い、
　デバイスメモリという特殊なメモリであることに注意する。
　通常のメモリはGPUからアクセスすることができないため、
　GPUからアクセスできる特殊なメモリを用意する必要があり、それがデバイスメモリである。

　new,mallocなどで確保する通常のメモリとデバイスメモリの重要な違いとして、
　デバイスメモリには「種類」がある。デバイスメモリを使う際はどれを使うか適切に選ばなければならない。
　どんな種類のデバイスメモリがあるかは物理デバイス依存である。

・メモリを確保する時はvk::MemoryAllocateInfoに必要なメモリのサイズと種類を指定する。

・描画をするにあたり、まずレンダーパスというものが必要になる。
　レンダーパスとは、一言で言えば描画の処理順序を記述したオブジェクトであり、
　描画処理の際には必ず必要になる。
　おおざっぱな計画書みたいなものであり、コマンド(具体的な作業手順)とは別物。

　レンダーパスの情報を構成するものは以下の3つがある。

アタッチメント
　→ レンダーパスにおいて描画処理の対象となる画像データのこと。

サブパス
　→ 1つの描画処理。単一または複数のサブパスが集まってレンダーパス全体を構成する。
　　サブパスは任意の個数のアタッチメントを入力として受け取り、任意の個数のアタッチメントに描画処理を出力する。

サブパス依存性
　→ サブパス間の依存関係。
　　つまり「サブパス1番が終わってからでないとサブパス2番は実行できない」などの関係を表す。

　レンダーパスはあくまで「この処理はこのデータを相手に、あの処理はあのデータを...」
　といった関係性を表す「枠組み」に過ぎないため、それぞれの処理(サブパス)が具体的に
　どのような処理を行うかは関知しない。

・パイプラインとは、3DCGの基本的な描画処理をひとつながりにまとめたものである。
　ほぼすべての3DCGは三角形の集まりであり、我々が最初に持っているものは
　三角形の各店の色や座標だが、最終的に欲しいものは画面のどのピクセルが
　どんな色なのかという情報である。この間をつなぐ演算処理は大体お決まりのパターンになっており、
　まとめてグラフィックスパイプラインというものになっている。

　そしてこの処理は全ての部分が固定されているのではなく、
　プログラマ側で色々なカスタムを指定する部分があり、それらの情報をまとめたものが
　「パイプラインオブジェクト」である。

　パイプラインオブジェクトを使用して描画処理を行う際には
　コマンドでパイプラインオブジェクトを指定し、ドローコールを呼ぶ。

　vulkanではグラフィックスパイプラインとコンピュートパイプラインの2種類がある。
　コンピュートパイプラインはGPGPUなどに使用する。
　普通に描画を行う際は、グラフィックスパイプラインを作成する。

・シェーダはパイプラインの中の主役と言っても過言ではないくらいになんでもできる。
　パイプラインとは「点の集まりでできた図形を色のついたピクセルの集合に変換するもの」で、
　シェーダはそのパイプラインの中において、あの点とこの点をあっちに動かしたりこっちに動かしたり、
　あのピクセルやこのピクセルを赤に塗ったり青に塗ったりする役割を果たす。

　昔はシェーダも簡素なことしかせず、文字通りただ「陰影をつけるもの」であり、
　処理内容もほぼ固定だったらしいが、今では自由にシェーダプログラムを書いて
　GPUに実行させることができる。空間を捻じ曲げ、複雑な模様を描き、
　モノや何かをべらぼうに増やすことさえもできる。

　しかし、何でもできるようになった代わりに、お決まりのような普通の処理しかしたくない場合でも
　それをちゃんと書かなければならず、デフォルト動作に任せる選択肢が存在しないのである。

　シェーダを使用するには、シェーダプログラムを書く必要がある。
　GLSLというC言語をベースとした専用言語を使用する。
　GLSLで書いたプログラムは、専用のソフトでSPIR-Vという中間言語にコンパイルし、
　Vulkanからはそれを読み込んで実行することになる。
　ちなみに、SPIR-Vの仕様はGLSLとは独立しており、実際にはGLSL以外の言語、
　例えばDirectXで使われるHLSLなどからもコンパイルすることが可能である。

・シェーダには種類がある。その中で最低限必要なものとして、
　頂点シェーダ(バーテックスシェーダ)、フラグメントシェーダを作成する。

　頂点シェーダは頂点1つごとに1回呼ばれ、その頂点の座標を出力する。

　フラグメントシェーダはピクセル1つごとに呼ばれ、そのピクセルの色を決定する。
　色はRGBA(RGBとαチャンネル)の4次元ベクトルで表現され、
　それぞれの値は0.0～1.0の実数で表現される。

・Vulkanでは画像の左上が(-1.0, -1.0)、右下が(1.0, 1.0)になる。
　つまり、半分の位置は0.0となる。

・GLSLをコンパイルするには、Vulkan SDKに付属のglslcというツールを使う。
　binディレクトリにあるため、パスを通すなどしてコマンドを使用できるようにする。

・イメージをパイプラインで描画の対象として扱うには、「イメージ」から「イメージビュー」という
　繋ぎのためのオブジェクトを作る必要がある。
　レンダーパスの中のそれぞれのアタッチメントにはイメージではなく、
　イメージビューを結びつけることになる。

　一つのイメージオブジェクトが複数のレイヤーを持つことができる。
　イメージビューによって、その中のどのレイヤーをアタッチメント(=描画対象)として使うのか
　と言った部分を指定することもできる。これはviewType,components,subresourceRange
　などで指定する。

　イメージとイメージビュの違いに対する一つの理解として、
　イメージが本当にただの画像を表すオブジェクトであることに対し、
　イメージビューは「どのイメージを扱うか」と、「そのイメージを描画処理の上でどのように扱うか」
　をひとまとめにしたオブジェクトだといった理解の仕方がある。

・レンダーパスはおおざっぱな計画書のようなものであるため、
　処理(サブパス)とデータ(アタッチメント)のつながりと関係性を記述するが、
　具体的な処理内容やどのデータを扱うかについては関与しない。
　具体的な処理内容はコマンドバッファに積むコマンドやパイプラインによって決まるが、
　具体的なデータの型を決めるためのものが「フレームバッファ」である。

　フレームバッファを介して「0番のアタッチメントにはこのイメージビュー、1番のアタッチメントは…」
　という結びつけを行うことで初めてレンダーパスが使えるようになる。

　初期化用構造体にレンダーパスの情報を入れた段階でレンダーパスとイメージビューが
　結びつくわけではないので注意する。この時入れているレンダーパスの情報はあくまで
　「このフレームバッファはどのレンダーパスと結びつけることができるのか」を表しているにすぎず、
　フレームバッファを作成した時点で結びついたわけではない。

　パイプラインの作成処理でもレンダーパスの情報を渡しているが、
　そこにも同じ事情がある。フレームバッファとパイプラインは特定のレンダーパスに依存して
　作られるものであり、互換性のない他のレンダーパスのために働こうと思っても
　そのようなことはできないのである。結びつけを行っているわけではないのに
　レンダーパスの情報を渡さなければならないのはそのためである。

・描画をするにあたり、まずはレンダーパスの開始と終了を支持するコマンドを送る必要がある。
　くどいようだが、vulkanにおける描画処理は必ずレンダーパスの枠組みで行う必要がある。

・複数のサブパスを持つレンダーパスを用いる場合はnextSubpass()メソッドで
　次のサブパスへ移行する。

・描画処理ではどのパイプラインを使って行うかを示さなければならない。
　これはbindPipeline()メソッドで行うことができる。

・stbと呼ばれるヘッダライブラリを使用すると、画像ファイルを簡単に扱うことができる。

・データはメインメモリではなく、GPUの中にある。つまりそのままでアプリケーションからアクセスできない。
　そこでアプリケーション側のアドレス空間上にマップして、メインのプログラムから見られるようにする必要がある。

　「GPU上のメモリには種類があり、適切に選択する必要がある」と以前に記載したが、
　GPU上のメモリには、GPUを操作しているPC側(ホスト)からアクセスできるものと
　できないものがある。そこで、メモリを確保するところで「目的のイメージにバインドできるメモリ」
　であるだけでなく、「ホスト側から見えるメモリ」であるものを選択する必要がある。

・表示する先の画面は「サーフェス」というオブジェクトで抽象化される。
　ウィンドウやスクリーンなど、表示する先として使える何かは全て
　サーフェスと言う同じ種類のオブジェクトで表され、統一的に扱うことができる。
　このような仕組みのため、「どこに表示しようとしているのか」を気にする必要が無い。
　サーフェスさえ取得すればあとは同じ処理で描画、表示ができるのである。

　しかし、サーフェスを作成する部分の処理はプラットフォーム依存になる。
　サーフェスは表示先を表すオブジェクトだが、具体的な表示先が何を表すのかは
　プラットフォーム次第だからである。Windowsであればウィンドウ、Androidであればアプリ、など。
　そのため、WindowsであればWindows専用のAPIでウィンドウ情報からサーフェスを作成する必要があり、
　AndroidであればAndroid専用のAPIでアプリ情報からサーフェスを作成しなければならない。

　そこで、そうしたプラットフォーム依存な部分を覆い隠してくれる便利な外部ライブラリを使用することで、
　効率的に開発を進めることができる。GLFW,SDLなどがある。

・vulkan.hppのインクルードは、GLFWの前にインクルードすることに注意する。

・vulkanにおいて「画面に表示する」という機能は拡張機能のため、
　拡張機能をオンにしないとサーフェスは作成できない。
　インスタンスの初期化処理のところで拡張機能をオンにすることができる。
　オンにする必要のある拡張機能の名前もプラットフォーム依存だが、
　GLFWはこの辺も上手くやってくれる。

・GLFWが返すのはVulkan.hppに包まれた形式ではなく、C言語の生Vulkanの形式である。
　GLFWはC++のライブラリではなくC言語のライブラリなので仕方がない。
　C言語形式のVulkanオブジェクトは、キャストやコンストラクタ処理などによって
　簡単にVulkan.hppの形式に変換できる。

・サーフェスはインスタンスに依存して作られるオブジェクトのため、
　破棄処理にはインスタンスの情報が必要になる。
　そのため、vkDestroySurfaceKHRの第一引数にはインスタンスを渡していたのである。

　今まで扱ってきたようなvk::Uniquexxx系のオブジェクトは、
　本体だけでなく親の情報も保持している。例えばレンダーパスは論理デバイスに依存して
　作られるオブジェクトなのでvk::UniqueRenderPassはレンダーパスそのものだけでなく、
　元となった論理デバイスも保持しているのである。
　そのため、デストラクタで破棄処理が行える。

VkSurfaceKHR c_surface;
VkResult result = glfwCreateWindowSurface(instance.get(), window, nullptr, &c_surface);
vk::UniqueSurfaceKHR surface(c_surface);

　上記コードで実行時エラーが起きてしまうことについて、
　今まではdevice->createRenderPassUnique()というように、
　そもそも親のメソッドでUniqueと名のついたスマートポインタを作成していた。
　しかし、GLFWのように作成処理がC言語の領域で行われ、返ってきた本体だけを基に
　スマートポインタを作成しても親の情報が無いため、実行時エラーになってしまう。
　具体的には、デストラクタでの破棄処理の時に持っていない親の情報を参照して、
　NullPointerExceptionでエラーとなってしまう。

・サーフェイスが取得できたら、次はスワップチェーンというオブジェクトを作成する必要がある。
　これは一言で言うと「画面に表示されようとしている画像の連なり」を表すオブジェクトである。

　コンピュータのアニメーションというのは高速で絵が切り替わる、いわゆる「パラパラ漫画」の
　仕組みで実現されている。このパラパラ漫画の1コマ1コマは一般に「フレーム」と呼ばれる。
　そして、(今どきの)一般的なコンピュータは、アニメーションを描画・表示する際に
　「描いている途中」が見えないようにするため、2枚以上のキャンバスを用意して、
　「1枚を使って現在のフレームを表示させている裏で別の1枚に次のフレームを描画する」
　という仕組みを採用している。
　この「2枚以上のキャンバス」を管理し、そしてサーフェイスと連携して表示するところまで
　やってくれるのがスワップチェーンと言うオブジェクトである。

　vulkanにおける表示処理はこのスワップチェーンを介して行うことになる。
　サーフェイスを直接いじることはない。

・スワップチェーンは拡張機能であるため、全ての物理デバイスがスワップチェーンの機能を
　サポートしているわけではない。つまり「あっちのGPUではスワップチェーンが使えるけれど
　こっちのGPUでは使えない」ということがあり得る。
　そのため、対応した物理デバイス(GPU)を選ぶ必要がある。

　また、拡張機能であるためサーフェイスと同じく機能を有効化する必要がある。
　しかし、サーフェイスと違う点がある。それはスワップチェーンは「デバイスレベル」の
　拡張機能であるということ。拡張機能には、インスタンス単位でオンオフするものと、
　デバイス単位でオンオフするものがある。サーフェイスはインスタンスレベルの拡張機能なので
　インスタンス作成時に有効化したが、スワップチェーンはデバイス単位の拡張機能であるため、
　論理デバイス作成時に有効化する必要がある。

・vk::SurfaceCapabilitiesKHR, vk::SurfaeFormatKHR, vk::PresentModeKHR
　この3つのAPIは、「サーフェイスの情報」および「物理デバイスが対象のサーフェイスを扱う能力」
　の情報を取得するAPIである。ここで手に入れる情報を用いて諸々の値を決める。

・デバイスとサーフェイスの相性次第では、getSurfaceFormatsKHR(),getSurfacePresentModesKHR()
　の戻り値が空になるということがあり得るため、念のためこの2つのメソッドの戻り値が
　空でないかどうかの判定を物理デバイス選定の処理に記述した方が良い。

・3章では描画先となるイメージを自分で準備してそこに描画したが、
　スワップチェーンは自分でイメージを保持しているため、自分でイメージを手づから作成する必要はなく、
　スワップチェーンが元から保持しているイメージを取得してそこに描画することになる。

　スワップチェーンからイメージを取得した後の流れは基本的に同じである。
　イメージからイメージビューを作成、レンダーパスやパイプラインなどの作成、
　フレームバッファを作成してイメージビューと紐づけ、コマンドバッファにコマンドを積んで
　キューに送信する。

　スワップチェーンは複数のイメージを持っているので、配列の形で取得することになる。
　そのため、複数のイメージそれぞれについてイメージビューを作成しなければならない。

　vk::ImageView.formatについて、ここに指定するフォーマットは元となるイメージに
　合わせる必要があるため、スワップチェーンのイメージの場合は
　スワップチェーンを作成する時に指定したフォーマットを指定しなければならない。
　そのため、vk::SurfaceFormatKHRの値を変数に保持しておいたのである。

・finalLayoutとは、イメージのメモリ上における配置方法・取り扱い方法に関する指定である。
　「イメージレイアウト」という。いろいろな設定があり、必要に応じて最適なものを指定しなければならない。
　間違ったものを指定するとエラーが出る場合もある。

　レンダーパスの設定によって、レンダリング処理が終わった後でどのようなイメージレイアウトにするかを
　決めることができる。今回はレンダリングが終わった後で表示(プレゼン)しなければならず、
　その場合はvk::ImageLayout::ePresentSrcKHRでなければならないという決まりのため、
　今回はこれを指定している。

　3章で指定したeGeneralは一応どんな扱いを受けても基本的にはOKらしく、
　eGeneralのままでも動くには動くが、やめておいた方が無難である。

・コマンドバッファに記録するコマンドには「どのフレームバッファを使って描画するか」
　という情報が内包されている。もし固定の内容のコマンドバッファを使ってしまうと、
　毎回同じフレームバッファが使われることになる。毎回同じフレームバッファということは、
　毎回同じイメージに向けて描画することになってしまう。これではスワップチェーンによる
　表示処理が上手くいかなくなってしまう。

　そこで、毎フレームコマンドバッファをリセットして、コマンドを記録し直すことにする。
　こうすることで毎回別のイメージに向けて描画できる。
　リセットできるようにするには、コマンドプール作成時にvk::CommandPoolCreateInfo.flagsに
　vk::CommandPoolCreateFlagBits::eResetCommandBufferを指定すると、
　そのコマンドプールから作成したコマンドバッファはリセット可能になる。
　なお、リセットの方法はコマンドバッファのreset()メソッドを呼び出すだけである。

・スワップチェーンは表示する画像(イメージ)を次々に切り替えていく機構である。
　スワップチェーンを利用する側としては、「次に表示される予定のイメージ」に
　描画を行いたいわけである。

　そこで、「次に描画を行うべきイメージ」を、論理デバイスのacquireNextImageKHR()メソッドで取得する。
　スワップチェーンのイメージを配列として取得したが、その何番目のイメージという番号の形で手に入る。
　このメソッドは次に描画するべきイメージを教えてくれるだけでなく、
　「描画されても良いように準備する処理」なども含んでいるため、
　スワップチェーンのイメージに描画する前には必ず呼ぶ必要がある。
　(正確には「描画された後表示されても良いように準備する処理」の方が近い)

　acquireNextImageKHR()は直ちに描画の準備を整えてくれるわけではないため、
　少し待たないと描画の準備を完了してくれない。
　イメージのインデックスは戻り値として先に返してくれる。
　そのため、フェンスなどを利用して描画の準備が終わるまで待機する必要がある。

・イメージの表示(プレゼンテーション)もGPUの仕事である。
　GPUの仕事ということはつまり、キューにコマンドを送信することになる。

　ここでまた少し面倒なのが、どの物理デバイスのどのキューかによって、
　プレゼンテーションの機能をサポートしている場合とサポートしていない場合があり得る。
　ある物理デバイスのあるキューが、あるサーフェイスへのプレゼンテーションを行えるかどうかは、
　物理デバイスのgetSurfaceSupportKHR()メソッドで行える。

・プレゼンテーションを行うにはキューにそのコマンドを送る必要がある。
　今まではコマンドバッファにコマンドを送信していたが、この場合はプレゼンテーションではコマンドバッファは経由しない。
　プレゼンテーションのコマンドはキューに直接送信するAPIがあるため、それを使用する。
　プレゼンテーションはキューのpresentKHR()メソッドで行う。

・処理の順序に関して、守るべき処理の順序をGPUにあらかじめ教え込んでおき、
　アプリケーション側は他のことに集中した方が良い。

　現在、毎フレームやっている処理を整理すると、

1.次フレームで描画するイメージの準備
2.レンダリング
3.画面へのプレゼンテーション

　ということになる。この順番は崩せない。
　レンダリングはイメージが準備できるまでできず、プレゼンテーションはレンダリングが終わるまでできない。
　ということは、2つのセマフォを作る必要がある。

・何かしら送った命令が実行中の状態でプログラムが終了するとよくないため、
　プログラムが終了する前には1回waitIdle()を挟んでおく。

・これまで作ったものには重大な欠陥がある。
　それは、ウィンドウをリサイズするとたちまちエラーを吐いて終了してしまうことである。
　これは、描画対象(サーフェイス)の状態が変化すると、スワップチェーンが無効になってしまうためである。
　このような場合も正常に動くアプリを作るには、無効になったスワップチェーンを作り直す
　処理を実装する必要がある。

　まず、スワップチェーンが無効になったらそのことを検出する必要がある。
　これは、acquireNextImageKHR()の戻り値を見ることでわかる。
　戻り値はvk::Resultであり、正常な場合はeSuccessになるが、
　ウィンドウのリサイズのようなスワップチェーンの有効性にかかわる問題が起きた場合は
　eSuboptimalKHR, eErrorOutOfDateKHR のいずれかになる。
　それぞれの意味については以下の通り。

eSuboptimalKHR
　→ まだ正常に動作することができるが、もうスワップチェーンはサーフェイスと正しく整合した状態ではない。

eErrorOutOfDateKHR
　→ もはや完全に使えない状態になった。もう無理。

　Suboptimalの場合は必ずしも直ちに再作成する必要はないが、
　現段階では再作成してしまうことにする。
　スワップチェーンを作り直す場合、実際にはスワップチェーンに依存して作られるオブジェクト群も
　同時に作り直す必要がある。具体的にはスワップチェーンのイメージから作られるイメージビュー、
　およびイメージビューから作られるフレームバッファがその対象である。

　とりあえず、スワップチェーン及び再作成の必要があるオブジェクト群の作成処理を
　1つの関数にまとめてしまうとよい。最初の作成時もリサイズによる再作成時も
　処理は共通しているため、関数にまとめてしまえば再利用できる。
　しかし、再作成時のために破棄処理が入ることには注意する。

・以下コードについて、

auto recreateSwapchain = [&](){
    swapchainFramebufs.clear();
    swapchainImageViews.clear();
    swapchainImages.clear();
    swapchain.reset();
	
	...
	
　これは戻り値をautoで推論したラムダ式を記述している？
　[&] のところは「キャプチャ」と呼ぶらしいが、ここに&だけを指定したら
　このラムダ式以前に宣言された全ての変数の参照をこのラムダ式内で
　使用できるということなのだろうか？

　cpprefjpを確認したところ、以下のような記載があった。
https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html
　「ラムダ式からその外側の変数を使用するには、「キャプチャ(capture)」という機能を使用する。
　ラムダ式の先頭にある [ ] は「ラムダ導入子(lambda-introducer)」と呼ばれ、
　どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。
　キャプチャの方式としては、参照かコピーのいずれかを選択できる。」

void f()
{
  int x = 3;

  // この時点で見える自動変数を参照でキャプチャし、
  // 参照した変数xを書き換える
  auto f = [&] { x = 1; };

  // 個別にキャプチャ方法を指定する場合は、
  // 以下のように、&の次に変数名を指定する
  // auto f = [&x] { x = 1; };

  f(); // x == 1
}

　また、キャプチャ記法には色々あり、
　例えば[&]はその時点で見える自動変数を参照してラムダ式の中で使用することに対し、
　[=]はその時点で見える自動変数をコピーしてラムダ式の中で使用する。
　[&x]のように特定の変数のみ指定してラムダ式の中で使用することも可能。
　であれば、参照する変数を絞った方が良いのではないか？記述は面倒になるが。
　メソッド内でも事前に宣言した4つしか使用していないし、変数を指定する形で記述する。
　いや全然他の変数も使ってた。目が節穴。

・vk::Resultではなくvk::ResultValue？
　なぜ判定に引っかからずに強制終了してしまう？
　差分のある個所
サーフェイスと相性の悪いGPUを弾く処理が参考サイトにはなくなっている、でもこれは必要では？

https://github.com/bwasty/vulkan-tutorial-hpp/blob/master/steps/18_vertex_buffer.cpp
もしかして、例外として投げられているから普通にif文で判定できていないのでは？
このサイトのコードのように、例外をキャッチする形にすれば再作成できるのでは？
メソッドに切り分ければ実現できそうではある。だがwhile文のループをどうcontinueするか？
上記で記載しているURL先のコードのように、クラスを定義してメンバとしてレンダーパスやら
論理デバイスやら必要なオブジェクトを持つようにして、それぞれの作成処理を
メソッドで定義する形にした方がよさそう。

公式チュートリアルのC++コードを写経していく形が良いかもしれない。
https://docs.vulkan.org/tutorial/latest/03_Drawing_a_triangle/00_Setup/00_Base_code.html

・以下コードのように、{}を用いてメンバを初期化するような書き方はC++20から可能。

constexpr vk::ApplicationInfo appInfo{ .pApplicationName   = "Hello Triangle",
            .applicationVersion = VK_MAKE_VERSION( 1, 0, 0 ),
            .pEngineName        = "No Engine",
            .engineVersion      = VK_MAKE_VERSION( 1, 0, 0 ),
            .apiVersion         = vk::ApiVersion14 };
			
　これは、指示付き初期化と呼ばれるもので{}による集成体初期化において
　メンバ名を指定して初期化が行える。
			
・公式チュートリアルなんかAPIとバージョンが変なことになってエラーで動かないので、
　公式じゃない方のチュートリアルでやっていく形にする。
https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Base_code

・vulkan api関数宣言の戻り値の型の前にはVKAPI_ATTR,
　型の後にはVKAPI_CALL を記述する。例としては以下の通り。

static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(...)

　こうすることで、debugCallback()に正しい引数などを指定できているか確認してくれる。
　上記の例では、デバッグコールバック関数を定義している。

・コールバックは、検証レイヤーのメッセージをトリガーしたvulkan呼び出しを中止するかどうかを
　示すbool値を返す。コールバックがtrueを返した場合、呼び出しは
　VK_ERROR_VALIDATION_FAILED_EXTエラーと共に中止される。
　これは通常、検証レイヤー自体のテストにのみ使用されるため、常にVK_FALSEを返す必要がある。

・vulkan apiはドライバのオーバーヘッドを最小限に抑えるという理念に基づいて設計されており、
　その目標の現れの一つとして、APIのデフォルトのエラーチェックは非常に限定的である。
　列挙型に誤った値を設定したり、必須パラメータにNULLポインタを渡したりするといった
　単純なミスでさえ、通常は明示的に処理されず、クラッシュや未定義の動作につながるだけである。

・バリデーションレイヤーはデフォルトでデバッグメッセージを標準出力に出力するが、
　プログラム内で明示的なコールバック関数を用意することで、これらのメッセージを
　処理することもできる。これにより、必ずしもすべてのメッセージが致命的なエラーであるとは
　限らないため、表示するメッセージの種類を選択できるようになる。	

　プログラム内でメッセージと関連する詳細を処理するためのコールバックを設定するには、
　VK_EXT_debug_utils拡張機能を使用してコールバック付きのデバッグメッセンジャーを
　設定する必要がある。このVK_EXT_debug_utilsを表す定数として
　VK_EXT_DEBUG_UTILS_EXTENSION_NAME が用意されている。

・vkCreateDebugUtilsMessengerEXT()メソッドは拡張関数であるため自動的には読み込まれない。
　vkGetInstanceProcAddr()を使用してアドレスを自分で調べる必要がある。

・vkDebugUtilsMessengerEXTもクリーンアップする必要があるため、
　vkDestroyDebugUtilsMessengerEXT()もvkGetInstanceProcAddr()で
　明示的に取得して、クリーンアップ処理内で実行する必要がある。

・vkCreateDebugUtilsMessengerEXTの呼び出しには有効なインスタンスが作成されている必要があり、
　インスタンスが破棄される前に呼び出す必要がある。そのため、vkCreateInstance(),
　vkDestroyInstance()でデバッグをするには、少し処理を加える必要がある。

　これらの関数の呼び出し専用のDebugUtilsMessengerを別途作成する方法がある。
　これは、vkInstanceCreateInfo構造体のpNextメンバに、
　vkDebugUtilsMessengerCreateInfoEXT構造体へのポインタを渡すだけでよい。
　こうすれば、vkCreateInstance(),vkDestroyInstance()でも
　デバッグメッセンジャーを使用することができる。

・vkPhysicalDeviceはvkInstanceが破棄される際に暗黙的に破棄されるため、
　cleanup()に新たな処理を追加する必要はない。

・物理デバイスの選定について、デバイスが適合するかどうかを単純に確認して
　最初に選んだデバイスを選択するのではなく、各デバイスにスコアをつけて
　最も高いスコアを持つデバイスを選択するという方法もある。
　こうすることで、専用グラフィックカードに高いスコアをつけて優先的に使用し、
　他に統合GPUしかない場合は統合GPUにフォールバックすることができる。

・0.0から1.0までの浮動小数点数を使用して、キューに優先順位を割り当てることができる。
　pQueuePrioritiesに指定していたのはこのような値である。

・論理デバイスはインスタンスと直接対話しないため、
　destroyのパラメータとしてインスタンスが含まれていない。

・createInfoの宣言でちゃんと空の{}をつけないと、
　なんかいろいろ警告やらエラーみたいなものが出るのでちゃんと初期化するようにする。

・vulkanには「デフォルトフレームバッファ」という概念が無いため、
　画面に表示する前のレンダリングバッファを管理するインフラストラクチャが必要である。
　このインフラストラクチャはスワップチェーンと呼ばれ、明示的に作成する必要がある。
　スワップチェーンは、基本的に画面に表示されるのを待っている画像のキューである。
　スワップチェーンの一般的な目的は、画像の表示を画面のリフレッシュレートと同期させることである。

・スワップチェーンにおいて基本的に確認する必要があるプロパティは以下の3種類がある。

基本的なサーフェイス機能(スワップチェーン内の画像の最小/最大数、画像の幅と高さの最小/最大)
サーフェイスフォーマット(ピクセル形式、色空間)
利用可能なプレゼンテーションモード

　それぞれ上からVkSurfaceCapabilitiesKHR,VkSurfaceFormatKHR,
　VkPresentModeKHRで表される。

・最適なスワップチェーンを実現するために適切な設定を見つけるべきものは以下の3種類がある。

サーフェイスフォーマット(色深度)
プレゼンテーションモード(画像を画面に「スワップ」するための条件)
スワップ範囲(スワップチェーン内の画像の解像度、というかサイズ？)

・VkSurfaceFormatKHR(サーフェイスフォーマット)には、
　format,colorSpaceメンバが含まれる。

　formatは、カラーチャンネルとタイプを指定する。
　例えば、VK_FORMAT_B8G8R8A8_SRGBは、B,G,R,αチャンネルをこの順序で
　8ビットの符号なし整数に格納し、ピクセル当たり合計32ビットとなることを意味する。
　色空間についてはSRGBを利用するとより正確な色を表現できるため、
　SRGBが利用可能な場合はそれを使用するとよい。
　上記で例に挙げたVK_FORMAT_B8G8R8A8_SRGBはもっとも一般的なフォーマットの一つである。

　colorSpaceは、VK_COLOR_SPACE_SRGB_NONLINEAR_KHRフラグを使用して
　SRGBカラースペースがサポートされているかどうかを示す。

・プレゼンテーションモードは、画面に画像を表示する際の実際の条件を表すため、
　スワップチェーンにとって最も重要な設定と言える。
　VK_KHR_surfaceでは以下の4つのモードが利用可能である。

VK_PRESENT_MODE_IMMEDIATE_KHR
　→ アプリケーションから送信された画像はすぐに画面に転送されるため、
　　ティアリングが発生する可能性がある。

VK_PRESENT_MODE_FIFO_KHR
　→ スワップチェーンはキューのような構造で、ディスプレイが更新されるタイミングで
　　キューの先頭のイメージが表示される。アプリケーションは描画済みのイメージを
　　キューの末尾に追加する。もしキューが満杯であれば、
　　アプリケーションは次に空きができるまで待機する必要がある。
　　この挙動は、現代のゲームでよく使われる垂直同期(V-Sync)に最も近いものである。
　　なお、ディスプレイが更新される瞬間のことを「垂直ブランク」と呼ぶ。

VK_PRESENT_MODE_FIFO_RELAXED_KHR
　→ FIFO_KHRとほとんど同じだが、アプリケーションの描画が遅れ、
　　最後の垂直ブランク時にキューが空だった場合にのみ違いが発生する。
　　次の垂直ブランクを待つのではなく、イメージが到着した時点で画像を転送する。
　　そのため、ティアリングが発生する可能性がある。

VK_PRESENT_MODE_MAILBOX_KHR
　→ FIFO_KHRの派生バージョン。
　　違いは、キューが満杯の時にアプリケーションをブロックするのではなく、
　　キューに既にある画像を新しい画像に置き換える点である。
　　このモードでは、ティアリングを回避しながらフレームを可能な限り高速に
　　レンダリングできるため、標準的な垂直同期よりも遅延が少なくなるという利点がある。
　　この仕組みは一般的に「トリプルバッファリング」として知られているが、
　　バッファが3つあるだけでは、必ずしもフレームレートがロック解除されるとは限らない。

　エネルギー消費が問題にならないのであれば、MAILBOX_KHRを選択するのが良い。
　垂直ブランク直前まで可能な限り最新の画像をレンダリングすることで
　ティアリングを回避しながら、レイテンシをかなり低く抑えることができる。
　エネルギー消費が重要なモバイルデバイスでは、代わりにFIFO_KHRを使用する方が良い。

・スワップ範囲はスワップチェーンイメージの解像度で、描画先のウィンドウの
　ピクセル解像度とほぼ同じになる。可能な解像度の範囲は
　VkSurfaceCapabilitiesKHR構造体で定義される。
　vulkanでは、メンバの幅と高さを設定することでウィンドウの解像度と一致させるように指示される。
　ただし、一部のウィンドウマネージャではこれを変更することも許可されており、
　その場合はcurrentExtentがuint32_tの最大値に設定される。
　こうすると、minImageExtentとmaxImageExtentの範囲内で
　ウィンドウのサイズに最も近い解像度を自分で選ぶ必要がある。
　その際には正しい単位(ピクセル単位)で解像度を指定する必要があることに注意する。

・GLFWはサイズを測定する時に、ピクセルと画面座標の2つの単位を使用する。
　しかし、vulkanはピクセルで動作するため、スワップチェーンの範囲もピクセルで指定する必要がある。
　高DPIディスプレイを使用している場合、画面座標はピクセルに対応しない。
　ピクセル密度が高いため、ピクセル単位のウィンドウの解像度は、
　画面座標での解像度よりも大きくなる。そのため、vulkanがスワップ範囲を修正しない場合は
　元の値をそのまま使用することはできない。
　そこで、glfwGetFrameBufferSize()を利用してピクセル単位のウィンドウの解像度を
　取得する必要がある。

・スワップチェーンに含める画像の数について、最小サイズにすると
　レンダリング用の次の画像を取得する前に、ドライバが内部処理を完了するのを
　待たなければならない場合がある。そのため、最小サイズ + 1 を指定するのが良い。

・VkSwapCreateInfoKHRについて

　imageArrayLayersは、各画像が何レイヤーで構成されるかを指定する。
　これは立体視3Dアプリケーション以外では常に1となる。

　imageUsageは、スワップチェーン内の画像をどのような操作に使用するかを指定する。
　例えば、VK_IMAGE_USAGE_COLOR_ATTACHMENT_BITでは
　画像に直接レンダリングする、つまり画像はカラーアタッチメントとして使用される。
　VK_IMAGE_USAGE_TRANSFER_DST_BITを使用すると、後処理などの操作を実行するために
　最初に別の画像に画像をレンダリングすることも可能である。
　メモリ操作によってレンダリングされた画像をスワップチェーン画像に転送することができる。

　複数のキューファミリーで使用されるスワップチェーン画像の処理方法を指定する必要がある。
　今回のアプリケーションでは、グラフィックス、プレゼンテーションのキューがそれぞれ
　異なる場合にこれを指定する必要がある。スワップチェーン内の画像はグラフィックスキューから
　描画し、プレゼンテーションキューに送信する。複数のキューからアクセスされる画像を
　処理する方法は、以下の2つがある。

VK_SHARING_MODE_EXCLUSIVE
　→ イメージは一度に1つのキューファミリによって所有され、別のキューファミリで使用する前に
　　所有権を明示的に譲渡する必要がある。このオプションは最高のパフォーマンスを提供する。

VK_SHARING_MODE_CONCURRENT
　→ 所有権を明示的に譲渡することなく、イメージを複数のキューファミリにわたって使用できる。

　並行モードではqueueFamilyIndexCount,pQueueFamilyIndicesパラメータを使用して、
　どのキューファミリ間で所有権を共有するかを事前に指定する必要がある。

　preTransformは、90度時計回りや水平反転などの特定の変換を
　適用するように指定できる。(capabilitiesでsupportedTransformsがサポートされている場合)
　変換を適用しない場合はcurrentTransformを指定して現在の変換を指定する。

　compositeAlphaは、ウィンドウシステム内の他のウィンドウとのブレンドに
　アルファチャンネルを使用するかどうかを指定する。ほとんどの場合で
　アルファチャンネルは無視する方が望ましいため、VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR
　を指定するとよい。

　clippedは、VK_TRUEを設定すると「隠れて見えないピクセルの色については気にしない」
　といった設定ができる。例えば、他のウィンドウが重なって前面に表示されている場合など。

　oldSwapchainは、スワップチェーンを再作成する場合に古いスワップチェーンへの
　参照を指定する必要がある。スワップチェーンを1つだけ作成する場合は、
　VK_NULL_HANDLEを指定する。

・スワップチェーンから取得したイメージは、スワップチェーンが破棄されると自動的に
　クリーンアップされるため、cleanup()にコードを追加する必要はない。

・イメージビューは画像へのアクセス方法と、画像のどの部分にアクセスするかを指定する。
　例えば、2Dテクスチャとして扱うのか、深度テクスチャとして扱うのか、
　ミップマップを使うのか使わないのか、などといったことを定義する。

・VkImageViewCreateInfoについて、

　viewTypeのパラメータにより、画像を1Dテクスチャ,2Dテクスチャ,3Dテクスチャ、
　キューブマップとして扱うことができる。

　formatは、画像データの解釈方法を指定する。

　componentsは、カラーチャンネルの配置を変更できる。
　つまり、RGBA要素の入れ替えについてのパラメータである。
　例えば、全てのチャンネルを赤チャンネルにマッピングしてモノクロテクスチャを作成できる。
　また、定数の値をチャンネルにマッピングすることもできる。

　subresourceRangeは、イメージの用途とイメージのどの部分にアクセスするかを指定する。
　今回ではカラーターゲットとして使用され、ミップマップレベルや複数のレイヤーは使用しない。
　立体3Dアプリケーションを開発している場合は、複数のレイヤーを持つスワップチェーンを作成する。
　そして、異なるレイヤーにアクセスすることで、各画像に対して左目と右目のビューを表す
　複数の画像ビューを作成できる。

・グラフィックパイプラインとは、メッシュの頂点とテクスチャをレンダーターゲットの
　ピクセルへと変換する一連の処理のことである。

・GLSLについて、

　ベクトル型はvecと要素の数である数値を組み合わせた文字列で表現される。
　例えば3D座標はvec3の形で格納される。vec3(...).x のように、
　メンバを介して単一のコンポーネントにアクセスすることもできる。
　複数のコンポーネントから同時に新しいベクトルを作成することもできる。
　例えば、vec3(1.0,2.0,3.0).xy は vec2 となる。
　ベクトルのコンストラクタは、ベクトルオブジェクトとスカラー値の組み合わせを取ることもできる。
　例えば、vec3は vec3(vec2(1.0,2.0), 3.0) のように構築することができる。

・頂点シェーダーは、入力される各頂点を処理する。
　頂点のワールド座標、色、法線座標、テクスチャ座標などの属性を入力として受け取る。
　出力はクリップ座標における最終的な位置と、色やテクスチャ座標など、
　フラグメントシェーダーに渡す必要がある属性である。これらの値はラスタライザによって
　フラグメント全体に補間され、滑らかなグラデーションを生成する。

　クリップ座標は頂点シェーダから得られる4次元ベクトルであり、
　その後、ベクトル全体をその最後の要素で割ることで、正規化されたデバイス座標に変換される。
　この正規化されたデバイス座標は、フレームバッファを[-1,1]*[-1,1]の座標系に
　マッピングする同次座標である。
　フレームバッファ座標は左上が0,0、右下が1920,1080のようになる座標で、
　正規化されたデバイス座標は左上が-1,-1、右下が1,1になる座標である。
　Z座標は0から1の範囲となる。

　main()は全ての頂点に対して呼び出される。

・頂点シェーダーからの位置によって形成される三角形は、
　画面上の領域をフラグメントで塗りつぶす。
　フラグメントシェーダーはこれらのフラグメントに対して呼び出され、
　フレームバッファ(または複数のフレームバッファ)の色と深度を生成する。

　main()はすべてのフラグメントに対して呼び出される。
　GLSLの色はR,G,B,αチャンネルの4成分ベクトルで、範囲は[0,1]である。
　フレームバッファごとにleyout(location = 0)修飾子でフレームバッファの
　インデックスを指定する独自の出力変数を指定する必要がある。

・glslc shader.vert -o vert.spv のようにしてコンパイルを行う。

・SPIR-VバイトコードをGPUで実行するためのマシンコードにコンパイル及びリンク処理は、
　グラフィックスパイプラインが作成されるまで行われない。
　つまり、パイプラインの作成が完了したらすぐにシェーダーモジュールを破棄できるため、
　シェーダーモジュールはクラス変数ではなくパイプライン作成関数のローカル変数にするのが良い。

・VkPipelineShaderStageCreateInfoについて、

　stageは、シェーダーがどのパイプラインステージで使用されるかを指定する。

　moduleは、コードを含むシェーダーモジュールを指定する。

　pNameは、呼び出す関数(エントリポイント)を指定する。
　複数のフラグメントシェーダーを1つのシェーダーモジュールに統合し、
　異なるエントリポイントを使用してそれぞれの動作を区別することが可能である。

　pSpecializationInfoは、シェーダー定数の値を指定できる。
　今回は使用していないが、単一のシェーダーモジュールを使用する場合、
　そのモジュール内で使用される定数に異なる値を指定することにより、
　パイプライン作成時にその動作を設定できる。これは、レンダリング時に変数を使用して
　シェーダーを設定するよりも効率的である。それらの変数の値に依存するif文を
　削除するなどの最適化をコンパイラが行えるためである。

・パイプラインの状態のほとんどはパイプラインステートに固定化する必要があるが、
　一部の状態は描画時にパイプラインを再作成することなく変更可能である。
　例としては、ビューポートのサイズ、線幅、ブレンド定数などが挙げられる。
　これらのプロパティを描画時に指定できるようにしたい場合、
　VkDynamicStateオブジェクトと、VkPipelineDynamicStateCreateInfo構造体を
　使用する必要がある。これによりそれらの値の設定は無視され、
　代わりに描画時にデータを指定する形になる(その指定も必須となる)
　こうすることで、より柔軟な設定が可能となり、ビューポートやシザーステートといった
　パイプラインに固定化してしまうとより複雑な設定になってしまうようなものによく使用される。

・VkPipelineVertexInputStateCreateInfo構造体は、
　頂点シェーダーに渡される頂点データの形式を記述する。
　これは、主に以下の2つの方法で記述される。

バインディング
　→ データ間の間隔と、そのデータが頂点ごとかインスタンスごとかを指定する。

属性記述
　→ 頂点シェーダに渡される属性の型、それらをどのバインディングから読み込むか、
　　どのオフセットで読み込むかを指定する。

　今回は、頂点データを頂点シェーダー内に直接ハードコーディングしているため、
　この構造体には「読み込む頂点データが無い」ことを指定する。
　もし指定する場合、pVertexBindingDescriptions,pVertexAttributeDescriptions
　メンバに頂点データの読み込みに関する詳細を記述した構造体の配列を指定する。

・VkPipelineInputAssemblyStateCreateInfo構造体は、
　頂点からどのようなジオメトリを描画するか、プリミティブ再スタートを有効にするかを指定する。

　前者はtopologyメンバで指定され、以下のような値を取ることができる。

VK_PRIMITIVE_TOPOLOGY_POINT_LIST
　→ 頂点ごとに点を描画する。各頂点が単独の点として表示される。

VK_PRIMITIVE_TOPOLOGY_LINE_LIST
　→ 各2頂点から1本の線分を描画する。
　　[v0,v1],[v2,v3]...

VK_PRIMITIVE_TOPOLOGY_LINE_STRIP
　→ 各線分の終点が、次の線分の始点として再利用される。
　　[v0,v1],[v1,v2]...

VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST
　→ 各3頂点から1つの三角形を描画する。
　　[v0,v1,v2],[v3,v4,v5]...

VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP
　→ 各三角形の2,3番目の頂点が、次の三角形の最初の2点として再利用される。
　　[v0,v1,v2],[v1,v2,v3]...

　通常、頂点はインデックス順に頂点バッファから連続して読み込まれるが、
　要素バッファを使うことでどのインデックスを使うかを自分で指定することができる。
　これにより、頂点の再利用などの最適化が可能になる。
　primitiveRestartEnableメンバをVK_TRUEに設定すると、
　_STRIP系のトポロジーモードにおいて、0xFFFF,0xFFFFFFFFのような
　特殊なインデックスを使って、線や三角形の連なりを分割することができる。

・ビューポートとは、基本的に出力がレンダリングされるフレームバッファの領域を表す。
　ほとんどの場合、(0,0)から(width,height)になる。

　スワップチェーンやその画像のサイズは、ウィンドウのサイズと異なる場合があることに注意する。
　スワップチェーンの画像は後でフレームバッファとして使われるため、それらのサイズに合わせるべきである。

　minDepth,maxDepthは、フレームバッファで使う奥行(Z値)の範囲を指定する。
　この値は[0.0f, 1.0f]の範囲内である必要があるが、
　minDepthの方がmaxDepthより大きくても構わない。
　特別なことをしない限り、0.0f～1.0fを使うのが一般的である。

　シザー矩形について、
　ビューポートは「画像からフレームバッファへの変換」を定義するが、
　シザー矩形は「実際にピクセルが保存される領域」を定義する。
　シザー矩形の外にあるピクセルは、ラスタライザーによって破棄される。
　つまり、変換というよりはフィルターのような働きをする。
　シザー矩形がビューポートより大きい場合、ビューポートの結果がそのまま映し出される。
　したがって、フレームバッファ全体に描画したい場合は、
　フレームバッファ全体をカバーするシザー矩形を指定する。

　ビューポートとシザー矩形は、パイプラインの固定状態として指定することも、
　コマンドバッファ内で動的状態としてその都度設定することも可能である。
　固定状態として設定する場合は他の状態とより整合性が取れるが、
　動的に設定する場合は柔軟性が大きく向上するため非常に便利である。
　動的に設定する方法は非常に一般的であり、全ての実装でパフォーマンス低下なしに
　行うことができる。

　動的なビューポートやシザー矩形を使用する場合は、
　それぞれに対応するVkDynamicStateを有効にする必要がある。
　そして、パイプライン作成時には動的な設定を用いるビューポートやシザー矩形などの
　数を指定するだけでよい。実際のビューポートやシザー矩形は後で描画時に設定される。
　動的状態を変更すると、単一のコマンドバッファ内で異なるビューポートやシザー矩形を
　指定することもできる。

　設定方法に関係なく、一部のグラフィックカードでは複数のビューポートとシザー矩形を使用できるため、
　構造体のメンバにはそれらの配列を参照する。複数のビューポートとシザー矩形を
　使用するためには、GPU機能を有効にする必要がある。(論理デバイスの作成を参照。)

・ラスタライザは、頂点シェーダから頂点によって形作られたジオメトリを受け取り、
　フラグメントに変換して、フラグメントシェーダにより色付けできるようにする。
　また、深度テスト、表裏判定によるカリング、シザーテストのような処理も行う。
　更に、ポリゴン全体を埋めるフラグメントを出力するか、
　エッジのみ(ワイヤーフレームレンダリング)を出力するかを設定できる。
　これらすべての設定は、VkPipelineRasterizationStateCreateInfo構造体を
　使用して設定する。

　depthClampEnableがVK_TRUEの場合、ニアクリップ面やファークリップ面を
　超えたフラグメントが破棄されるのではなく、対応するクリップ面にクランプ(押し込まれる)される。
　これは、シャドウマップのような特殊なケースで役立つ。
　この機能を使うには、GPUの特定の機能を有効にする必要がある。

　rasterizerDiscardEnableがVK_TRUEの場合、
　ジオメトリはラスタライザステージを一切通過しなくなる。
　つまり、頂点シェーダやジオメトリシェーダまでは実行されるが、
　フラグメントは生成されないため、フレームバッファへの出力が完全に無効化される。

　polygonModeは、ジオメトリのフラグメント生成方法を決定する。以下のモードが利用可能。

VK_POLYGON_MODE_FILL
　→ ポリゴン内部をフラグメントで塗りつぶす。

VK_POLYGON_MODE_LINE
　→ ポリゴンのエッジ(辺)だけが線として描かれる。

VK_POLYGON_MODE_POINT
　→ ポリゴンの各頂点だけが点として描かれる。

　塗りつぶし以外のモードを使用するには、GPU機能を有効にする必要がある。

　linewidthは、線の太さを「フラグメントの数」で指定する。
　サポートされる線の最大の太さはハードウェアによって異なり、
　1.0fよりも太い線を使用する場合は、GPUのwideLines機能を有効化する必要がある。

　cullModeは、面カリングの種類を決定する。
　カリングを無効、前面、背面の片方のみカリング、両面をカリングなどの指定ができる。
　frontFaceメンバは、度の頂点の並び順を前面と見なすかを指定する。
　この順序は時計回りか反時計回りのどちらかになる。

　depthBiasEnableをVK_TRUEに設定すると、
　定数値を追加したり、フラグメントの傾きに基づいてバイアスをかけることで
　深度を変更することができる。これはシャドウマッピングに使用されることがある。

・VkPipelineMultisampleStateCreateInfo構造体は、マルチサンプリングの設定を行う。
　マルチサンプリングは、アンチエイリアシングを行う方法の一つである。
　マルチサンプリングでは、同じピクセルにラスタライズされた複数のポリゴンの
　フラグメントシェーダ結果を合成することにより、ジャギーを軽減する。
　ジャギーは特にエッジに発生しやすいため、主にエッジに沿って行われる。
　マルチサンプリングは1つのピクセルに対して1枚のポリゴンしか重なっていない場合には、
　フラグメントシェーダを複数回実行する必要が無いため、
　単純に高解像度で描画してから縮小する方法よりも、大幅に処理コストが軽くなる。
　マルチサンプリングの機能を使うには、GPUの機能を有効にする必要がある。

・深度バッファやステンシルバッファを使用している場合は、
　VkPipelineDepthStencilStateCreateInfo構造体を使用して
　深度テストとステンシルテストも設定する必要がある。

・フラグメントシェーダが色を返した後、その色は既にフレームバッファに存在する色と
　合成される必要がある。この変換をカラーブレンディングと呼ぶ。
　カラーブレンディングには以下の2つの方法がある。

1．古い値と新しい値を混ぜて最終的な色を作る
2．古い値と新しい値をビット演算で合成する

　カラーブレンディングを設定するための構造体は2種類ある。
　VkPipelineColorBlendAttachmentState構造体は、
　各フレームバッファごとの設定を行う。これは1つ目の古い値と新しい値を混ぜて
　最終的な色を作る方法のカラーブレンディングを設定できる。
　blendEnableがVK_FALSEに設定されている場合、
　フラグメントシェーダから出てきた新しい色がそのまま通される。
　VK_TRUEの場合は、2つの混合処理が行われて新しい色が計算される。
　colorWriteMaskによって許可されたチャンネルだけが有効になり、
　他のチャンネルは破棄される。
　カラーブレンディングのもっとも一般的な方法は、アルファブレンディングを実装することである。
　これは、新しい色の透過性に基づいて新しい色と古い色をブレンドする。

　VkPipelineColorBlendStateCreateInfo構造体は、
　グローバルのカラーブレンディング設定を行う。
　全てのフレームバッファの構造体の配列を参照し、
　計算でブレンド係数として使用できるブレンド定数を設定できる。
　logicOpEnableは、ビット演算による合成を行いたい時にVK_TRUEに設定する。
　使用するビット演算はlogicOpメンバに指定できる。
　この設定をすると、自動的に1つ目の方法が無効になる。
　これは、全てのフレームバッファに対して blendEnableをVK_FALSEにしたのと同じである。
　このモードでもcolorWriteMaskが使われ、フレームバッファのどのカラーチャンネルに
　影響を与えるかを決定する。

　今回行っているように、両方のモードを無効にすることも可能であり、
　その場合はフラグメントシェーダから出力された色がそのままフレームバッファに書き込まれる。

・VkPipelineLayoutは、シェーダー内でuniformを使用するために指定する必要がある。
　シェーダー内でのuniform値について、これはグローバル変数のようなもので、
　描画時に変更できるという点でダイナミックステート変数に似ている。
　シェーダーを再作成せずに挙動を変えることができるため便利である。
　一般的には、頂点シェーダーに変換行列を渡すためや、フラグメントシェーダーで
　テクスチャサンプラーを作成するために使われる。
　シェーダーに動的な値を渡すもう一つの方法であるプッシュ定数を指定することもできる。

・パイプラインの作成を完了する前に、描画時に使用するフレームバッファの
　アタッチメントについてvulkanに伝える必要がある。
　カラーバッファと深度バッファがいくつあるのか、それぞれに何サンプル使用するのか、
　そしてレンダリング操作中にその内容をどのように扱うのかといった情報を指定する必要がある。
　これらの情報は全てレンダーパスオブジェクトにまとめられる。

・VkAttachmentDescriptionについて、

　formatは、スワップチェーンイメージの形式と一致する必要がある。

　samplesは、マルチサンプリングについて指定する。

　loadOp,storeOpは、レンダリングの前後でアタッチメント内のデータをどう扱うかを決定する。
　これらは、色データと深度データに適用される。
　loadOpでは、以下のような選択肢がある。

VK_ATTACHMENT_LOAD_OP_LOAD
　→ アタッチメントの既存の内容を保持する。

VK_ATTACHMENT_LOAD_OP_CLEAR
　→ 開始時に定数値で内容をクリアする

VK_ATTACHMENT_LOAD_OP_DONT_CARE
　→ 既存の内容は未定義であり、気にする必要はない。

　今回は、新しいフレームを描画する前にフレームバッファを黒でクリアするため、CLEARを指定する。

　storeOpでは、以下の2つの選択肢がある。

VK_ATTACHMENT_STORE_OP_STORE
　→ 描画された内容をメモリに保持し、後から読み取れるようにする。

VK_ATTACHMENT_STORE_OP_DONT_CARE
　→ レンダリング後のフレームバッファの内容は未定義になる。

　今回は、レンダリングされた三角形を画面に表示したいため、STOREを指定する。

　stencilLoadOp,stencilStoreOpは、ステンシルデータに適用される。
　今回はステンシルバッファに対して何も行わないため、読み込みと保存の結果は無関係なので
　DONT_CAREを指定する。

　initialLayoutは、レンダリングパス開始前の画像のレイアウトを指定する。
　finalLayoutは、レンダリングパス終了時に自動的に遷移するレイアウトを指定する。
　vulkanのテクスチャとフレームバッファは、VkImageオブジェクトとして表現され、
　特定のピクセルフォーマットを持っている。ただし、ピクセルがメモリ上でどのように配置されるかは、
　その画像で何をしようとしているかによって変わる。
　最も一般的なレイアウトは以下の通り。

VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
　→ カラーアタッチメントとして使用される画像用

VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
　→ スワップチェーンで表示される画像用

VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
　→ メモリコピー操作の転送先として使用される画像用

　現時点で知っておくべき重要なことは、画像を次に関連する操作に適した
　特定のレイアウトに移行する必要があるということである。
　initialLayoutにVK_IMAGE_LAYOUT_UNDEFINEDを指定すると、
　画像が以前のレイアウトに存在していたかどうかは考慮されない。
　これを使用する際の注意点は画像の内容が保持される保証がないことだが、
　今回はクリアするので問題はない。
　finalLayoutについては今回は画像をスワップチェーンで画面表示できるようにしたいため、
　PRESENT_SRC_KHRを指定する。

・1つのレンダーパスは複数のサブパスで構成できる。
　サブパスとは、前のパスのフレームバッファの内容に依存する後続のレンダリング操作である。
　例えば、複数のホストプロセス効果を順番に適用するようなシーケンスがこれにあたる。
　これらのレンダリング操作を1つのプロセスにまとめると、vulkanは操作の順序を変更したり、
　メモリ帯域幅を節約してパフォーマンスを向上させることができる。
　今回は1つだけのサブパスを使用する。

　各サブパスはVkAttachmentDescription構造体を用いて説明した
　1つ以上のアタッチメントを参照し、VkAttachmentReference構造体を使用する。

　attachmentは、アタッチメントの配列インデックスによって参照するアタッチメントを指定する。

　layoutは、この参照を使用するアタッチメントがサブパス中にどのレイアウトを使用するか指定する。
　vulkanは自動的にアタッチメントをこのレイアウトに遷移させる。
　今回はこのアタッチメントをカラーバッファとして機能させるため、
　COLOR_ATTACHMENT_OPTIMAL指定するとよい。

・サブパスはVkSubpassDescription構造体を使用して記述する。

　pipelineBindPointは、サブパスの種類を指定する。
　グラフィックスサブパス、またはコンピュートサブパスかを明示的に指定する。

　サブパスでは、以下のような種類のアタッチメントを参照できる。

pInputAttachments
　→ シェーダーから読み込まれるアタッチメント

pResolveAttachments
　→ マルチサンプリングのカラーアタッチメントに使われるアタッチメント

pDepthStencilAttachment
　→ 深度データ、ステンシルデータに使われるアタッチメント

pPreserveAttachments
　→ 指定したサブパスでは使用されないが、データが保存される必要があるアタッチメント

・vulkanでは、既存のパイプラインから派生して新しいグラフィックスパイプラインを作成できる。
　パイプラインの派生という考え方は、既存のパイプラインと多くの機能を共有する場合に、
　新しいパイプラインのセットアップコストを抑えることができ、同じ親を持つ
　パイプライン同士の切り替えも高速に行えるという仕組みである。

　VkGraphicsPipelineCreateInfo構造体の、

　basePipelineHandleは、既存のパイプラインのハンドルを指定する。

　basePipelineIndexは、これから作成される別のパイプラインをインデックスで参照できる。

・vkCreateGraphicsPipelines()は、複数のVkGraphicsPipelineCreateInfoオブジェクトを
　受取り、1回の呼び出しで複数のVkPipelineオブジェクトを作成するように設計されている。
　2番目のパラメータ、オプションのVkPipelineCacheオブジェクトを参照する。
　パイプラインキャッシュは、vkCreateGraphicsPipelines()の複数回の呼び出しに
　またがって、パイプライン作成に関連するデータを保存・再利用するために使用できる。
　キャッシュをファイルに保存すれば、プログラムの再実行をまたいで再利用することも可能である。
　これにより、後からパイプラインを作成する際の速度を大幅に向上させることができる。

・レンダーパス作成時に指定したアタッチメントは、VkFramebufferオブジェクトに
　ラップしてバインドされる。このフレームバッファオブジェクトは、アタッチメントを表す
　全てのVkImageViewオブジェクトを参照する。
　スワップチェーンのイメージを使用する場合、
　アタッチメントに使う画像は、スワップチェーンから取得される画像に依存するため、
　描画時に取得された画像に対応するフレームバッファを使えるようにするには、
　スワップチェーン内の全ての画像に対してフレームバッファを作成しておく必要がある。

・VkFramebufferCreateInfo構造体を用いるフレームバッファの作成は非常に単純。

　renderPassは、フレームバッファがどのレンダーパスと互換性を持つ必要があるかを指定する。
　ここで言う互換性を持つとは、大まかにアタッチメントの数や種類が同じであることを意味する。

　attachmentCount,pAttachmentsは、
　レンダーパスのpAttachment配列にある各アタッチメントにバインドすべきVkImageViewオブジェクトを指定する。

　layersは、画像配列のレイヤー数を表す。
　スワップチェーンは単一の画像なので、今回は1を指定する。

・vulkanのコマンド(描画操作やメモリ転送など)は、関数呼び出しによって直接実行されるわけではない。
　実行したい操作は全てコマンドバッファオブジェクトに記録する必要がある。
　この方法の利点は、vulkanに実行内容を伝える準備ができたら、
　全てのコマンドがまとめて送信されることである。全てのコマンドがまとめて利用できるため、
　vulkanはより効率的にコマンドを処理できる。
　更に、必要に応じてコマンド記録を複数のスレッドで実行することもできる。

・コマンドバッファを作成する前に、コマンドプールを作成する必要がある。
　コマンドプールはバッファを格納するためのメモリを管理し、
　コマンドバッファはそこから割り当てられる。
　コマンドプールの作成には、flags,queueFamilyIndexのパラメータのみが必要。

　flagsについて、コマンドプールには2つのフラグがある。フラグは以下の通り。

VK_COMMAND_POOL_CREATE_TRANSIENT_BIT
　→ コマンドバッファは新しいコマンドで頻繁に再記録される(メモリ割り当ての動作が変わる可能性がある)

VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
　→ コマンドバッファを個別に再記録できるようにする。
　　このフラグが無い場合、すべてまとめてリセットする必要がある。

　今回は毎フレームコマンドバッファを記録するため、リセットして再記録できるようにする必要がある。
　そのため、RESET_COMMAND_BUFFER_BITのフラグビットを設定する。

　コマンドバッファは取得したグラフィックスキューやプレゼンテーションキューなどの
　デバイスのキューのいずれかに送信することで実行される。
　各コマンドプールは、1種類のキューに送信されたコマンドバッファのみを割り当てることができる。
　今回は描画コマンドを記録するため、グラフィックスキューファミリーを選択する。

・コマンドバッファはコマンドプールが破棄されると自動的に解放されるため、
　明示的なクリーンアップは必要ない。

・VkCommandBufferAllocateInfo構造体について、

　levelは、割り当てられたコマンドバッファがプライマリかセカンダリかを指定する。

VK_COMMAND_BUFFER_LEVEL_PRIMARY
　→ 実行のためにキューに送信できるが、他のコマンドバッファから呼び出すことはできない。

VK_COMMAND_BUFFER_LEVEL_SECONDARY
　→ 直接送信することはできないが、プライマリコマンドバッファから呼び出すことができる。

　今回はセカンダリを使用しないが、プライマリからの一般的な操作を再利用すると
　便利であることは想像できる。

・VkCommandBufferBeginInfo構造体について、

　flagsは、コマンドバッファの使用方法を指定する。以下の値を指定できる。

VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
　→ コマンドバッファは一度実行した直後に再記録される。

VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT
　→ 完全に単一のレンダリングパス内で使われるセカンダリコマンドバッファ。

VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
　→ コマンドバッファは既に実行中であっても再度送信できる。

　現時点では、これらのフラグはいずれも適用できない。

　pInheritanceInfoは、セカンダリにのみ関係する。
　呼び出し元のプライマリからどの状態を継承するかを指定する。

　コマンドバッファが既に記録されている場合、vkBeginCommandBuffer()を呼び出すと、
　暗黙的にリセットされる。つまり、後からバッファにコマンドを追加することはできない。

・VkRenderPassBeginInfo構造体について、

　renderArea.offset | extent は、レンダリング領域のサイズを定義する。
　レンダリング領域は、シェーダーの読み込みと保存が行われる場所を定義する。
　この領域外のピクセルは未定義の値になる。
　最高のパフォーマンスを得るには、アタッチメントのサイズと一致させる必要がある。

　pClearValuesは、VK_ATTACHMENT_LOAD_OP_CLEARに使用するクリア値を定義する。
　これは、カラーアタッチメントのロード操作として我々が使ったものである。
　今回は、100%の不透明度を持つ黒に設定している。

・コマンドバッファにおいて、コマンドを記録する関数はすべてvkCmdxxxの形である。
　すべてvoidを返すため、記録が完了するまでエラー処理は行われない。
　全てのコマンドメソッドの最初の引数は、コマンドを記録するコマンドバッファである。

・vkCmdBeginRenderPass()メソッドの最後の引数は、
　レンダーパス内の描画コマンドの提供方法を制御する。値は以下の2つのいずれかになる。

VK_SUBPASS_CONTENTS_INLINE
　→ レンダーパスコマンドはプライマリ自体に埋め込まれ、セカンダリは実行されない。

VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
　→ レンダーパスコマンドはセカンダリから実行される。

・vkCmdDraw()について、

　firstVertexは、頂点バッファへのオフセットとして使用され、
　gl_VertexIndexの最小値を定義する。

　firstInstanceは、インスタンス化されたレンダリングのオフセットとして使用され、
　gl_InstanceIndexの最小値を定義する。

・基本的にvulkanでのフレームのレンダリングは、以下のような一連の共通手順で構成される。

1．前のフレームが終了するまで待つ
2．スワップチェーンから画像を取得する
3．その画像にシーンを描画するコマンドバッファを記録する
4．記録されたコマンドバッファを送信する
5．スワップチェーン画像を表示する

・GPU上で処理を開始する多くのvulkan API呼び出しは非同期であり、
　関数は操作が完了する前に戻る。

・セマフォはキュー操作間に順序付けを行うために使用される。
　キュー操作とは、コマンドバッファ内または関数内からキューに送信する作業を指す。
　キューの例としては、グラフィックスキューやプレゼンテーションキューなどがある。
　セマフォは、同じキュー内の作業と異なるキュー間の作業の両方に使用される。

　セマフォの注意点として、例えばvkQueueSubmit()のようなメソッドに
　セマフォを指定すると、待機はGPUでのみ発生し、CPUはブロックされることなく
　実行を継続する。CPUを待機させるには別の同期プリミティブが必要となる。

　フェンスは、CPU上の実行順序付けを目的としている。
　簡単に言うと、GPUが何かを完了したことをホストが知る必要がある場合にフェンスを使用する。
　セマフォとは異なり、ホストの実行がブロックされる。

　一般的に必要な場合を除き、ホストをブロックしないことが望ましい。
　GPUとホストに処理を与え続けるのが理想である。
　フェンスからの信号をただ待つのは効率的ではないため、
　作業を同期させるにはセマフォやその他の動機プリミティブを使用することが勧められる。

　フェンスを非シグナル状態に戻すには、手動でリセットする必要がある。
　これは、フェンスがホストの実行を制御するために使用されるため、
　フェンスをリセットするタイミングはホストが決定するからである。
　ホストを介さずにGPUの作業を指示するために使用されるセマフォとは対照的である。

　要約すると、セマフォはGPU上の操作の実行順序を指定するために使用され、
　フェンスはCPUとGPUを相互に同期させるために使用される。

・vkAcquireNextImageKHR()について、

　最後のパラメータは、利用可能になったスワップチェーン画像のインデックスを
　出力する変数を指定する。このインデックスはswapChainImages配列内の
　VkImageオブジェクトを参照する。

・VkSubmitInfo構造体について、

　pWaitDstStageMaskは、パイプラインのどのステージで待機するかを指定する。
　今回は画像が利用可能になるまで色を書き込まずに待機したいため、
　カラーアタッチメントに書き込むグラフィックスパイプラインのステージを指定する。
　他の指定では、画像がまだ利用可能でない間にも、頂点シェーダーなどの実行を開始できる。

・vkQueueSubmit()は、処理の負荷が大きい場合の効率性を高めるために、
　VkSubmitInfo構造体の配列を引数として受け取る。
　最後のパラメータでは、コマンドバッファの実行が終了した際に通知される
　オプションのフェンスを参照する。これにより、コマンドバッファを安全に再利用できる
　タイミングを判断できる。今回はinFlightFenceを指定する。

・レンダーパス内のサブパスは、画像レイアウトの遷移を自動的に処理する。
　これらの遷移は、サブパス間のメモリと実行の依存関係を指定する
　サブパス依存関係によって制御される。現在、サブパスは1つだけだが、
　このサブパスの直前と直後の処理も暗黙的な「サブパス」としてカウントされる。

　レンダーパスの開始時と終了時の遷移を処理する組み込み依存関係が2つあるが、
　開始時の遷移は適切なタイミングで発生しない。
　この組み込み依存関係は、パイプラインの開始時に遷移が発生すると想定しているが、
　その時点ではまだスワップチェーンの画像を取得できていない。
　この問題に対処する方法として、2つの方法がある。
　1つ目は、imageAvailableSemaphoreのwaitStagesを
　VK_PIPELINE_STAGE_TOP_OF_PIPE_BITに変更することで、
　イメージが利用可能になるまでレンダーパスを開始させないようにすること。
　2つ目は、レンダーパスがVK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
　ステージを待つようにすること。2つ目の方法はサブパス依存関係を

・サブパスの依存関係は、VkSubpassDependency構造体で記述する。

　srcSubpass,dstSubpassは、依存元と依存先のサブパスのインデックスを指定する。
　特殊な値であるVK_SUBPASS_EXTERNALは、レンダーパスの外部にある暗黙のサブパスを表す。
　srcSubpass,dstSubpassのどちらに指定されているかで、
　レンダーパスの前の処理、後の処理のどちらを指すのかが変化する。
　今回自身で設定したサブパスは1つだけなので、インデックス0がその唯一のサブパスを指す。
　依存関係に循環が発生しないように、dstSubpassはsrcSubpassよりも大きくなければならない。
　ただし、どちらか一方がVK_SUBPASS_EXTERNALの場合は、この制約は適用されない。

　srcStageMask,srcAccessMaskは、どの操作を待つか、
　およびその操作がどのパイプラインステージで発生するかを指定する。
　画像にアクセスするには、スワップチェーンが画像からの読み取りを完了するまで
　待機する必要がある。そのため、今回はカラーアタッチメントの出力ステージ自体を
　レンダーパスで待機することで実現できる。

・現段階では同一のコマンドバッファを再利用しているため、
　次のフレームのレンダリングを開始する前に、前のフレームのレンダリングが完了するまで
　待機しなければならず、ホストが不必要にアイドル状態になってしまう。
　この問題を解決するには、複数のフレームを同時に処理できるようにすればよい。
　つまり、あるフレームのレンダリングが次のフレームの記録を妨げないようにすればよいため、
　複数のコマンドバッファ、セマフォ、フェンスを用意すればよいのである。

・現段階では、ウィンドウサイズの変化などによってウィンドウサーフェイスが変化すると、
　スワップチェーンが対応できなくなる可能性がある。
　これらのイベントをキャッチし、スワップチェーンを再作成する必要がある。
　スワップチェーンの画像を直接参照しているイメージビュー、
　スワップチェーンの画像に直接依存しているフレームバッファも再作成する必要がある。

　再作成するオブジェクトの古いバージョンが再作成前に確実にクリーンアップされるように、
　クリーンアップコードの一部を別の関数に移動する必要がある。

　簡潔にするため今回はレンダーパスを再作成しないが、理論上ではスワップチェーンの
　画像フォーマットはアプリケーションのライフタイム中に変更される可能性がある。
　例えば、ウィンドウを標準レンジからハイダイナミックレンジモニターに移動した場合など。
　この場合、ダイナミックレンジ間の変更が適切に反映されるように、
　アプリケーションはレンダーパスを再作成する必要があるかもしれない。

　chooseSwapExtent()メソッドは、glfwGetFramebufferSize()を使用しているため、
　既に新たなウィンドウ解像度を照会しているので、特に変更する必要はない。

　今回の再作成方法では、新しいスワップチェーンを作る前に
　全てのレンダリングを停止しなければならない。
　しかし、古いスワップチェーンを使った描画処理が実行中の状態でも、
　新しいスワップチェーンを作成することは可能である。その場合は、
　VkSwapchainCreateInfoKHR構造体のoldSwapChainフィールドに
　古いスワップチェーンを指定し、古いスワップチェーンの使用が完全に終わった時点で破棄する。

　vulkanは通常、プレゼンテーション中にスワップチェーンが適切でなくなったことを通知する。
　vkAcquireNextImageKHR(),vkQueuePresentKHR()は、
　これを示すために以下の特別な値を返すことができる。

VK_ERROR_OUT_OF_DATE_KHR
　→ スワップチェーンがサーフェイスと互換性が無くなり、レンダリングに使用できなくなった。
　　通常、ウィンドウのサイズ変更後に発生する。

VK_SUBOPTIMAL_KHR
　→ スワップチェーンを使用してサーフェイスに正常に表示することはできるが、
　　サーフェイスのプロパティは完全には一致しなくなる。

　多くのドライバやプラットフォームではウィンドウのサイズ変更後に
　自動的にVK_ERROR_OUT_OF_DATE_KHRトリガーが実行されるが、
　必ずしも実行されるとは限らない。そのため、サイズ変更を明示的に処理するための
　コードを追加した方が良い。今回ではframebufferResized変数を新たに追加し、
　vkQueuePresentKHR()メソッドの戻り値を判定する際の条件式に、
　その変数を真であるかどうかの条件も追加している。
　vkAcquireNextImageKHR()の方にこの変数を条件式を追加していないのは、
　このメソッドはvulkanで完結するものだからドライバやプラットフォームには依存せず、
　必ずトリガーされることが保証されているからなのだろうか？

・ウィンドウリサイズを行うコールバック関数をstaticで定義する理由は、
　GLFWがHelloTriangleApplicationのインスタンスへの正しいthisポインタを使って
　メンバ関数を呼び出す方法を知らないからである。
　ただし、コールバック関数ではGLFWwindowへの参照が取得でき、
　その中に任意のポインタを格納できるglfwSetWindowUserPointer()メソッドがある。
　このメソッドでHelloTriangleApplicationのthisポインタを渡しているため、
　ウィンドウリサイズコールバック関数内でframebufferResizedメンバに
　アクセスができているのである。

・ここからの数章では、頂点シェーダーにハードコードされた頂点データを
　メモリ上の頂点バッファに置き換えていく。まずはCPUから見えるバッファを作成し、
　memcpyを使って直接頂点データをコピーする最も簡単な方法から始め、
　その後にステージングバッファを使用して頂点データを高性能メモリに
　コピーする方法を見ていく。

・まず、頂点シェーダーを変更してシェーダーコード自体に頂点データを含めないようにする。
　頂点シェーダーは、inキーワードを使用して頂点バッファから入力を受け取る。

　inPosition,inColorの変数は頂点属性である。
　これらは頂点ごとに頂点バッファ内で指定されるプロパティで、
　以前は2つの配列を使って各頂点に位置と色を手動で指定していたのと同じである。
　頂点シェーダを再コンパイルするのを忘れないようにする。

　layout(location = x) というアノテーションは入力にインデックスを
　割り当てており、後でそれを使って参照することができる。
　ただし注意すべき点として、dvec3(64ビットの3要素ベクトル)のような一部の型は、
　複数のスロットを使用することがあるため、そういった変数の前後では
　インデックスを少なくとも2以上離した番号にする必要がある。

・インターリーブとは、データを交互に配置していくことを示す。
　例えば、3Dモデルの各頂点のXY座標、RGBカラーをインターリーブして配列に詰めると
　3つの頂点の情報は以下のようにレイアウトされることになる。

XYRGBXYRGBXYRGB...

https://maku.blog/p/wqjqbpi/

・GPUメモリにアップロードされたデータ形式を頂点シェーダーに渡す方法を
　指定しなければならない。この情報を伝達するために必要な構造体として、
　VkVertexInputBindingDescription, VkVertexInputAttributeDescription構造体がある。

　頂点バインディングは、頂点全体を通してメモリからデータをロードする速度を記述したり、
　データエントリ間のバイト数や、各頂点の後または各インスタンスの後に
　次のデータエントリに移動するかどうかを指定する。

　VkVertexInputBindingDescription構造体について、
　bindingは、バインディング配列内のインデックスを指定する。
　strideは、あるエントリから次のエントリまでのバイト数を指定する。
　inputRateは、以下のいずれかの値を取ることができる。

VK_VERTEX_INPUT_RATE_VERTEX
　→ 各頂点の後の次のデータエントリに移動する。

VK_VERTEX_INPUT_RATE_INSTANCE
　→  各インスタンスの後に次のデータエントリに移動する。

　属性記述構造体は、バインディング記述から生成された頂点データの塊から
　頂点属性を抽出する方法を記述する。今回は位置と色の2つの属性があるため、
　属性記述構造体も2つ必要である。

　VkVertexInputAttributeDescription構造体について、
　bindingは、頂点ごとのデータがどのバインディングから取得されるかをvulkanに伝える。
　locationは、頂点シェーダーの入力で指定されたlocationディレクティブを参照する。
　formatは、属性のデータ型を表す。フォーマットは色フォーマットと同じ列挙型で指定する。
　以下のシェーダー型とフォーマットはよく一緒に使われる。

float : VK_FORMAT_R32_SFLOAT
vec2 : VK_FORMAT_R32G32_SFLOAT
vec3 : VK_FORMAT_R32G32B32_SFLOAT
vec4 : VK_FORMAT_R32G32B32A32_SFLOAT

　カラーチャンネルの数がシェーダーデータ型のコンポーネント数と一致するフォーマットを
　使用する必要がある。シェーダーのコンポーネント数よりも多くのチャンネルを
　使用することもできるが、その場合は自動的に破棄される。
　チャンネル数がコンポーネント数よりも少ない場合、BGAコンポーネントは
　(0,0,1)のデフォルト値を使用する。カラータイプ(SFLOAT,UINT,SINT)と
　ビット幅もシェーダー入力の型と一致する必要がある。以下の例を参考。

ivec2 : VK_FORMAT_R32G32_SINT(32ビット符号付き整数2成分ベクトル)
uvec4 : VK_FORMAT_R32G32B32A32_UINT(32ビット符号なし整数4成分ベクトル)
double : VK_FORMAT_R64_SFLOAT(64ビット倍精度浮動小数点数)

　formatは属性データのバイトサイズを暗黙的に定義し、
　offsetは頂点ごとのデータ先頭からのバイト数を指定する。
　バインディングは1回につき1つのVertex構造体を読み込む。
　メンバであるpos,colorの位置をoffsetofマクロを使って自動的に計算し、指定する。

　VkPipelineVertexInputStateCreateInfo構造体の
　vertex Binding | Attribute DescriptionCountと、
　pVertex Binding | Attribute Descriptionsに
　getBindingDescription(),getAttributeDescriptions()
　が返す構造体の情報を指定することで、グラフィックスパイプラインへの設定が行える。

・vulkanにおけるバッファは、グラフィックカードから読み取れる、
　任意のデータを格納するメモリ領域である。
　これまで扱ってきたvulkanオブジェクトとは異なり、バッファは自動的にメモリを割り当てない。

・バッファを作成するには、VkBufferCreateInfo構造体に入力する。
　sizeは、バッファのサイズをバイト単位で指定する。
　usageは、バッファ内のデータがどのような目的で使用されるかを示す。
　今回は頂点バッファのみ指定するが、論理和を使用して複数の目的を指定することも可能。
　sharingModeは、特定のキューファミリーで所有するか、複数のキューファミリーで共有するかを指定する。

・バッファにメモリを割り当てるには、まずバッファに必要なメモリ量を照会する。
　これは、VkMemoryRequirements構造体と、
　vkGetBufferMemoryRequirements()を使用して取得できる。
　VkMemoryRequirements構造体について、
　sizeは、必要なメモリ量を指定する。VkBufferCreateInfo.sizeとは異なる場合がある。
　alignmentは、割り当てられたメモリ領域内でバッファが始まるオフセット。
　VkBufferCreateInfo.usage, flagsに依存する。
　memoryTypeBitsは、バッファに適したメモリタイプのビットフィールド。

　グラフィックカードは、割り当て可能なメモリの種類が異なる。
　メモリの種類によって、実行可能な操作やパフォーマンス特性が異なる。
　バッファの要件とアプリケーションの要件を組み合わせて、
　適切なメモリの種類を見つける必要がある。
　vkGetPhysicalDeviceMemoryProperties()で
　使用可能なメモリの種類に関する情報を取得できる。
　VkPhysicalDeviceMemoryProperties構造体には、
　memoryTypes,memoryHeapsの2つの配列がある。
　メモリヒープは専用のVRAMや、VRAMが不足した場合に使用されるRAM上の
　スワップ領域など、物理的に異なるメモリリソースを表す。
　これらのヒープの中には、様々な種類のメモリが存在する。

　頂点バッファに適したメモリタイプだけが重要なわけではない。
　頂点データをそのメモリに書き込むことも必要である。
　memoryTypes配列は、ヒープと各メモリタイプのプロパティを指定する
　VkMemoryType構造体で構成されている。
　プロパティはCPUから書き込みできるようにメモリをマッピングできるかどうかなど、
　メモリの特殊な機能を定義する。このプロパティは
　VK_MEMORY_PROPERTY_HOST_VISIBLE_BITで示される。
　今回は、VK_MEMORY_PROPERTY_HOST_COHERENT_BITも使用する必要があるが、
　メモリをマッピングする時にその理由を説明する。

　vkBindBufferMemory()の4番目のパラメータは、メモリ領域内のオフセット。
　今回は頂点バッファ専用に割り当てられているため、オフセットは単に0となる。
　オフセットが0以外の場合、VkMemoryRequirements.alignmentで
　割り切れる必要がある。

　頂点データのバッファへのコピーは、vkMapMemory()によって
　バッファメモリをCPUアクセス可能なメモリにマッピングすることで実行される。
　この関数は、オフセットとサイズで定義された、指定されたメモリリソース領域に
　アクセスすることを可能にする。また、メモリ全体をマップするための特別な値である
　VK_WHOLE_SIZEを指定することも可能である。
　最後から2番目のパラメータはフラグを指定するために使用できるが、
　現在のAPIではまだ利用可能なフラグは無いため、このパラメータは0に設定する必要がある。
　最後のパラメータは、マップされたメモリへのポインタの出力を指定する。

　キャッシュなどの理由により、ドライバがデータをバッファメモリにすぐにコピーしない場合がある。
　また、バッファへの書き込みがマップされたメモリにまだ反映されていない可能性もある。
　この問題に対処するには、以下の2つの方法がある。

1．VK_MEMORY_PROPERTY_HOST_COHERENT_BITが示す、
　　ホストコヒーレント(ホストが一貫している)なメモリヒープを使用する

2．マップされたメモリに書き込んだ後にvkFlushMappedMemoryRanges()を呼び、
　　マップされたメモリから読み込む前にvkInvalidateMappedMemoryRanges()を呼ぶ

　今回は、1番のアプローチを選択する。これは、マップされたメモリが割り当てられた
　メモリの内容と常に一致することを保証する。しかし、明示的なフラッシュよりも
　パフォーマンスがわずかに低下する可能性があることに留意する。
　それが問題にならない理由については、次の章で説明する。

　メモリ範囲のフラッシュやコヒーレントメモリヒープの使用は、
　ドライバがバッファへの書き込みを認識することを意味するが、
　それがGPU上で実際に見えるようになるわけではない。
　GPUへのデータ転送はバックグラウンド処理内で行われる処理であり、
　仕様では単に、次にvkQueueSubmit()を呼び出した時点で完了していることが
　保証されているだけである。

　あとは、レンダリング処理中に頂点バッファをバインドするだけである。
　vkCmdBindVertexBuffers()は、前章で設定したようなバインディングに
　頂点バッファをバインドするために使用される。コマンドバッファの次の2つのパラメータは、
　頂点バッファを指定するバインディングのオフセットと数を指定する。
　最後の2つのパラメータは、バインドする頂点バッファの配列と、
　頂点データの読み取り開始バイトオフセットを指定する。
　また、vkCmdDraw()のハードコードされた頂点数をバッファ内の頂点数を渡すように
　修正する必要がある。

・

　から

======================================================================

エラーやミス、わからなかったことなど

・std::array<VkVertexInputAttributeDescription, 2>
　を関数の戻り値にすると、「不完全型を返します」みたいなエラーや、
　関数内でstd::array<VkVertexInputAttributeDescription, 2> attributeDescriptions{};
　のように変数を宣言すると、「不完全型は使用できません」とエラーが出る。
　　→ 原因は、arrayヘッダをインクルードしていなかったこと。インクルードして解決。

・