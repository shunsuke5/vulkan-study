・全ての機能はインスタンスを介して利用する。

・Vulkan-Hppでは、破棄処理の必要なほぼすべてのオブジェクト型について
　vk::Uniquexxx のような対応する型があり、またそれに対応した
　createxxxUniqueのような関数が存在する。destroy()メソッドで明示的に
　破棄しなくてよくなるため、積極的に使用した方が良い。

・vk::InstanceCreateInfo という構造体に色々な情報を乗せることで、
　Vulkanの拡張機能をオンにしたり、デバッグ情報を表示させるといったことができる。

・物理デバイスはvk::PhysicalDevice型で表される。

・GPUの能力を使うような機構は、全て論理デバイスを通して利用する。
　物理デバイスを直接いじることはできない。

・レイヤーという機能があり、vulkanのAPIを呼んだ際の処理に
　様々な追加処理を入れることができる。

　その中の1つにバリデーションレイヤーがある。
　これを使うとデバッグに非常に役立つ。以下のように指定して使用する。

    auto requiredLayres = { "VK_LAYER_KHRONOS_validation" };

https://chaosplant.tech/do/vulkan/ex1/

・Vulkanにおけるキューとは、GPUの実行するコマンドを保持する待ち行列のこと。
　GPUにコマンドを送るときは、このキューにコマンドを詰め込むことになる。
　1つのGPUが持っているキューは1つだけとは限らず、いくつも持っている場合がある。
　また、キューによってサポートしている機能としていない機能があったりするため、
　キューにコマンドを送るときは、そのキューが何の機能をサポートしているかを
　事前に把握しておく必要がある。

　キューファミリとは、同じ能力を持っているキューをひとまとめにしたもの。
　1つの物理デバイスには1個以上のキューファミリがあり、
　1つのキューファミリには1個以上の同等の機能を持ったキューが所属する。

・論理デバイスからキューを取得する時、論理デバイスにあらかじめ
　使用するキューを伝えておく必要がある。vk::DeviceCreateInfo構造体に
　vk::DeviceQueueCreateInfo構造体の配列を指定して、
　「この論理デバイスを通じてこのキューファミリからいくつのキューを使う」
　といった情報を指定する必要があるのである。
　(サイトで実行時エラーになるべきところでエラーにならなかったので、
　バージョンが変わって挙動が変わったのだろうか？)

・キューはdestroyする必要が無いため、uniqueもない。

・GPUにコマンドを送るときはキューにコマンドを詰め込むと記載があったが、
　より正確には「コマンドバッファの中にコマンドを記録し、そのコマンドバッファを
　キューに送る」という手続きをとる。そのため、コマンドを送信する際には
　必ずコマンドバッファが必要になる。

　コマンドバッファを作るには、前段階として「コマンドプール」という
　別のオブジェクトを作る必要がある。コマンドバッファをコマンドの記録に使う
　オブジェクトとするならば、コマンドプールはコマンドを記録するための
　メモリ実体のようなものである。コマンドバッファを作る際には必ず必要になる。

・vk::Queue#submit()でGPUに命令を送ることができるが、あくまで「送る」だけなので
　submit()から処理が返ってきた段階で送った命令が完了されているとは限らない。
　実用的なプログラムを作るためには「依頼した処理が終わるまで待つ」
　方法を知る必要がある。これに必要なのが「セマフォ」や「フェンス」という機構である。

　GPUに投げた処理は基本的に非同期処理になる。そのため、レンダリングなどの処理を
　GPUに投げた場合、状況に応じて処理の完了を待つ必要がある。
　このための機構がセマフォ、フェンスである。これらの機構を適切に利用することで、
　処理の順序関係がおかしくならないで済む。

　この2つの主な違いは、フェンスがホスト側(CPU側)で待機するための機構であることに対し、
　セマフォは主にGPU内で他の処理を待機するための機構であることである。

　フェンスオブジェクトは内部的にシグナル状態と非シグナル状態の
　2状態を持っている。初期状態(あるいはリセット直後の状態)は非シグナル状態である。
　様々な処理に対して「この処理が終わったらこのフェンスをシグナル状態にする」
　といった設定ができ、GPUを利用するほとんどの関数は引数としてフェンスを渡せる。
　例として、キューのsubmit()メソッドの第二引数などでフェンスを渡すことができる。
　2つの状態は非シグナル状態が赤信号、シグナル状態が青信号のようなものである。

　セマフォもフェンスと同じく、シグナル状態と非シグナル状態の2つがあり、
　シグナル状態にいなるまで待機することができる。
　フェンスと違い、特定の処理の完了に引っ掛けるには構造体に指定することが多い。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　signalSemaphoreCount,pSignalSemaphores を用いる。
　ここに指定すると、送信したコマンドの処理が完了したときに指定した
　セマフォがシグナル状態になる。

　また、待機のために指定する場合も構造体に指定する。
　例として、コマンドバッファの送信時はvk::SubmitInfo構造体の
　waitSemaphoreCount,pWaitSemaphores,pWaitDstStageMask で
　待機するセマフォを指定する。
　pWaitDstStageMaskは、パイプラインのどの時点で待機するかを指定する。
　単純に処理の開始時点で待機するということもできるが、
　例えばフラグメントシェーダでだけ特定の処理の結果を待つ必要があるならば、
　「フラグメントシェーダの処理が始まるまで待機」ということにして
　頂点シェーダの処理などはシグナル状態を待たずに始める、といったこともできる。
　GPUの並列化能力に余裕がある場合はこのようにして、
　必要最低限の部分でだけ処理待ちをする方が効率が上がるわけである。

　セマフォはフェンスと違い、明示的にリセットする必要はない。
　そのセマフォのシグナル状態を待っていた処理が開始すると、自動でリセットされる。
　こうした動作をするため、ある1つの処理に複数の他の処理が依存するという場合は
　その数だけセマフォが必要となる。

　1つのセマフォのシグナルを複数の処理で待つことは一般的ではないため、
　フェンスのように信号機に例えて考えるのは適切ではないと思われる。
　セマフォとは「ある1つの処理の完了」と「ある1つの処理の開始」の
　順序関係の取り決めであり、1対1の関係を表す。

　同期のための機構は他にもパイプラインバリア、イベント、レンダーパスなど
　様々なものがある。その中でもフェンスとセマフォが最も基本的でわかりやすく、
　また使う機会も多いため最初に覚えておくとよい。
https://chaosplant.tech/do/vulkan/ex2/

・タイムラインセマフォという数値カウンターを持つ特殊で高機能なセマフォもあるが、
　Vulkanでは2状態のバイナリセマフォの方が基本的である。

・画像はvk::Imageと言うオブジェクトで表される。
　これはvk::DeviceのCreateImage()で作成できる。

・画像オブジェクトを扱うためには、イメージにメモリを確保して割り当てる必要がある。
　ここで言うメモリはnew,mallocで確保できる通常のメモリとは違い、
　デバイスメモリという特殊なメモリであることに注意する。
　通常のメモリはGPUからアクセスすることができないため、
　GPUからアクセスできる特殊なメモリを用意する必要があり、それがデバイスメモリである。

　new,mallocなどで確保する通常のメモリとデバイスメモリの重要な違いとして、
　デバイスメモリには「種類」がある。デバイスメモリを使う際はどれを使うか適切に選ばなければならない。
　どんな種類のデバイスメモリがあるかは物理デバイス依存である。

・メモリを確保する時はvk::MemoryAllocateInfoに必要なメモリのサイズと種類を指定する。

・描画をするにあたり、まずレンダーパスというものが必要になる。
　レンダーパスとは、一言で言えば描画の処理順序を記述したオブジェクトであり、
　描画処理の際には必ず必要になる。
　おおざっぱな計画書みたいなものであり、コマンド(具体的な作業手順)とは別物。

　レンダーパスの情報を構成するものは以下の3つがある。

アタッチメント
　→ レンダーパスにおいて描画処理の対象となる画像データのこと。

サブパス
　→ 1つの描画処理。単一または複数のサブパスが集まってレンダーパス全体を構成する。
　　サブパスは任意の個数のアタッチメントを入力として受け取り、任意の個数のアタッチメントに描画処理を出力する。

サブパス依存性
　→ サブパス間の依存関係。
　　つまり「サブパス1番が終わってからでないとサブパス2番は実行できない」などの関係を表す。

　レンダーパスはあくまで「この処理はこのデータを相手に、あの処理はあのデータを...」
　といった関係性を表す「枠組み」に過ぎないため、それぞれの処理(サブパス)が具体的に
　どのような処理を行うかは関知しない。

・パイプラインとは、3DCGの基本的な描画処理をひとつながりにまとめたものである。
　ほぼすべての3DCGは三角形の集まりであり、我々が最初に持っているものは
　三角形の各店の色や座標だが、最終的に欲しいものは画面のどのピクセルが
　どんな色なのかという情報である。この間をつなぐ演算処理は大体お決まりのパターンになっており、
　まとめてグラフィックスパイプラインというものになっている。

　そしてこの処理は全ての部分が固定されているのではなく、
　プログラマ側で色々なカスタムを指定する部分があり、それらの情報をまとめたものが
　「パイプラインオブジェクト」である。

　パイプラインオブジェクトを使用して描画処理を行う際には
　コマンドでパイプラインオブジェクトを指定し、ドローコールを呼ぶ。

　vulkanではグラフィックスパイプラインとコンピュートパイプラインの2種類がある。
　コンピュートパイプラインはGPGPUなどに使用する。
　普通に描画を行う際は、グラフィックスパイプラインを作成する。

・シェーダはパイプラインの中の主役と言っても過言ではないくらいになんでもできる。
　パイプラインとは「点の集まりでできた図形を色のついたピクセルの集合に変換するもの」で、
　シェーダはそのパイプラインの中において、あの点とこの点をあっちに動かしたりこっちに動かしたり、
　あのピクセルやこのピクセルを赤に塗ったり青に塗ったりする役割を果たす。

　昔はシェーダも簡素なことしかせず、文字通りただ「陰影をつけるもの」であり、
　処理内容もほぼ固定だったらしいが、今では自由にシェーダプログラムを書いて
　GPUに実行させることができる。空間を捻じ曲げ、複雑な模様を描き、
　モノや何かをべらぼうに増やすことさえもできる。

　しかし、何でもできるようになった代わりに、お決まりのような普通の処理しかしたくない場合でも
　それをちゃんと書かなければならず、デフォルト動作に任せる選択肢が存在しないのである。

　シェーダを使用するには、シェーダプログラムを書く必要がある。
　GLSLというC言語をベースとした専用言語を使用する。
　GLSLで書いたプログラムは、専用のソフトでSPIR-Vという中間言語にコンパイルし、
　Vulkanからはそれを読み込んで実行することになる。
　ちなみに、SPIR-Vの仕様はGLSLとは独立しており、実際にはGLSL以外の言語、
　例えばDirectXで使われるHLSLなどからもコンパイルすることが可能である。

・シェーダには種類がある。その中で最低限必要なものとして、
　頂点シェーダ(バーテックスシェーダ)、フラグメントシェーダを作成する。

　頂点シェーダは頂点1つごとに1回呼ばれ、その頂点の座標を出力する。

　フラグメントシェーダはピクセル1つごとに呼ばれ、そのピクセルの色を決定する。
　色はRGBA(RGBとαチャンネル)の4次元ベクトルで表現され、
　それぞれの値は0.0～1.0の実数で表現される。

・Vulkanでは画像の左上が(-1.0, -1.0)、右下が(1.0, 1.0)になる。
　つまり、半分の位置は0.0となる。

・GLSLをコンパイルするには、Vulkan SDKに付属のglslcというツールを使う。
　binディレクトリにあるため、パスを通すなどしてコマンドを使用できるようにする。

・イメージをパイプラインで描画の対象として扱うには、「イメージ」から「イメージビュー」という
　繋ぎのためのオブジェクトを作る必要がある。
　レンダーパスの中のそれぞれのアタッチメントにはイメージではなく、
　イメージビューを結びつけることになる。

　一つのイメージオブジェクトが複数のレイヤーを持つことができる。
　イメージビューによって、その中のどのレイヤーをアタッチメント(=描画対象)として使うのか
　と言った部分を指定することもできる。これはviewType,components,subresourceRange
　などで指定する。

　イメージとイメージビュの違いに対する一つの理解として、
　イメージが本当にただの画像を表すオブジェクトであることに対し、
　イメージビューは「どのイメージを扱うか」と、「そのイメージを描画処理の上でどのように扱うか」
　をひとまとめにしたオブジェクトだといった理解の仕方がある。

・レンダーパスはおおざっぱな計画書のようなものであるため、
　処理(サブパス)とデータ(アタッチメント)のつながりと関係性を記述するが、
　具体的な処理内容やどのデータを扱うかについては関与しない。
　具体的な処理内容はコマンドバッファに積むコマンドやパイプラインによって決まるが、
　具体的なデータの型を決めるためのものが「フレームバッファ」である。

　フレームバッファを介して「0番のアタッチメントにはこのイメージビュー、1番のアタッチメントは…」
　という結びつけを行うことで初めてレンダーパスが使えるようになる。

　初期化用構造体にレンダーパスの情報を入れた段階でレンダーパスとイメージビューが
　結びつくわけではないので注意する。この時入れているレンダーパスの情報はあくまで
　「このフレームバッファはどのレンダーパスと結びつけることができるのか」を表しているにすぎず、
　フレームバッファを作成した時点で結びついたわけではない。

　パイプラインの作成処理でもレンダーパスの情報を渡しているが、
　そこにも同じ事情がある。フレームバッファとパイプラインは特定のレンダーパスに依存して
　作られるものであり、互換性のない他のレンダーパスのために働こうと思っても
　そのようなことはできないのである。結びつけを行っているわけではないのに
　レンダーパスの情報を渡さなければならないのはそのためである。

・描画をするにあたり、まずはレンダーパスの開始と終了を支持するコマンドを送る必要がある。
　くどいようだが、vulkanにおける描画処理は必ずレンダーパスの枠組みで行う必要がある。

・複数のサブパスを持つレンダーパスを用いる場合はnextSubpass()メソッドで
　次のサブパスへ移行する。

・描画処理ではどのパイプラインを使って行うかを示さなければならない。
　これはbindPipeline()メソッドで行うことができる。

・stbと呼ばれるヘッダライブラリを使用すると、画像ファイルを簡単に扱うことができる。

・データはメインメモリではなく、GPUの中にある。つまりそのままでアプリケーションからアクセスできない。
　そこでアプリケーション側のアドレス空間上にマップして、メインのプログラムから見られるようにする必要がある。

　「GPU上のメモリには種類があり、適切に選択する必要がある」と以前に記載したが、
　GPU上のメモリには、GPUを操作しているPC側(ホスト)からアクセスできるものと
　できないものがある。そこで、メモリを確保するところで「目的のイメージにバインドできるメモリ」
　であるだけでなく、「ホスト側から見えるメモリ」であるものを選択する必要がある。

・表示する先の画面は「サーフェス」というオブジェクトで抽象化される。
　ウィンドウやスクリーンなど、表示する先として使える何かは全て
　サーフェスと言う同じ種類のオブジェクトで表され、統一的に扱うことができる。
　このような仕組みのため、「どこに表示しようとしているのか」を気にする必要が無い。
　サーフェスさえ取得すればあとは同じ処理で描画、表示ができるのである。

　しかし、サーフェスを作成する部分の処理はプラットフォーム依存になる。
　サーフェスは表示先を表すオブジェクトだが、具体的な表示先が何を表すのかは
　プラットフォーム次第だからである。Windowsであればウィンドウ、Androidであればアプリ、など。
　そのため、WindowsであればWindows専用のAPIでウィンドウ情報からサーフェスを作成する必要があり、
　AndroidであればAndroid専用のAPIでアプリ情報からサーフェスを作成しなければならない。

　そこで、そうしたプラットフォーム依存な部分を覆い隠してくれる便利な外部ライブラリを使用することで、
　効率的に開発を進めることができる。GLFW,SDLなどがある。

・vulkan.hppのインクルードは、GLFWの前にインクルードすることに注意する。

・vulkanにおいて「画面に表示する」という機能は拡張機能のため、
　拡張機能をオンにしないとサーフェスは作成できない。
　インスタンスの初期化処理のところで拡張機能をオンにすることができる。
　オンにする必要のある拡張機能の名前もプラットフォーム依存だが、
　GLFWはこの辺も上手くやってくれる。

・GLFWが返すのはVulkan.hppに包まれた形式ではなく、C言語の生Vulkanの形式である。
　GLFWはC++のライブラリではなくC言語のライブラリなので仕方がない。
　C言語形式のVulkanオブジェクトは、キャストやコンストラクタ処理などによって
　簡単にVulkan.hppの形式に変換できる。

・サーフェスはインスタンスに依存して作られるオブジェクトのため、
　破棄処理にはインスタンスの情報が必要になる。
　そのため、vkDestroySurfaceKHRの第一引数にはインスタンスを渡していたのである。

　今まで扱ってきたようなvk::Uniquexxx系のオブジェクトは、
　本体だけでなく親の情報も保持している。例えばレンダーパスは論理デバイスに依存して
　作られるオブジェクトなのでvk::UniqueRenderPassはレンダーパスそのものだけでなく、
　元となった論理デバイスも保持しているのである。
　そのため、デストラクタで破棄処理が行える。

VkSurfaceKHR c_surface;
VkResult result = glfwCreateWindowSurface(instance.get(), window, nullptr, &c_surface);
vk::UniqueSurfaceKHR surface(c_surface);

　上記コードで実行時エラーが起きてしまうことについて、
　今まではdevice->createRenderPassUnique()というように、
　そもそも親のメソッドでUniqueと名のついたスマートポインタを作成していた。
　しかし、GLFWのように作成処理がC言語の領域で行われ、返ってきた本体だけを基に
　スマートポインタを作成しても親の情報が無いため、実行時エラーになってしまう。
　具体的には、デストラクタでの破棄処理の時に持っていない親の情報を参照して、
　NullPointerExceptionでエラーとなってしまう。

・サーフェイスが取得できたら、次はスワップチェーンというオブジェクトを作成する必要がある。
　これは一言で言うと「画面に表示されようとしている画像の連なり」を表すオブジェクトである。

　コンピュータのアニメーションというのは高速で絵が切り替わる、いわゆる「パラパラ漫画」の
　仕組みで実現されている。このパラパラ漫画の1コマ1コマは一般に「フレーム」と呼ばれる。
　そして、(今どきの)一般的なコンピュータは、アニメーションを描画・表示する際に
　「描いている途中」が見えないようにするため、2枚以上のキャンバスを用意して、
　「1枚を使って現在のフレームを表示させている裏で別の1枚に次のフレームを描画する」
　という仕組みを採用している。
　この「2枚以上のキャンバス」を管理し、そしてサーフェイスと連携して表示するところまで
　やってくれるのがスワップチェーンと言うオブジェクトである。

　vulkanにおける表示処理はこのスワップチェーンを介して行うことになる。
　サーフェイスを直接いじることはない。

・スワップチェーンは拡張機能であるため、全ての物理デバイスがスワップチェーンの機能を
　サポートしているわけではない。つまり「あっちのGPUではスワップチェーンが使えるけれど
　こっちのGPUでは使えない」ということがあり得る。
　そのため、対応した物理デバイス(GPU)を選ぶ必要がある。

　また、拡張機能であるためサーフェイスと同じく機能を有効化する必要がある。
　しかし、サーフェイスと違う点がある。それはスワップチェーンは「デバイスレベル」の
　拡張機能であるということ。拡張機能には、インスタンス単位でオンオフするものと、
　デバイス単位でオンオフするものがある。サーフェイスはインスタンスレベルの拡張機能なので
　インスタンス作成時に有効化したが、スワップチェーンはデバイス単位の拡張機能であるため、
　論理デバイス作成時に有効化する必要がある。

・vk::SurfaceCapabilitiesKHR, vk::SurfaeFormatKHR, vk::PresentModeKHR
　この3つのAPIは、「サーフェイスの情報」および「物理デバイスが対象のサーフェイスを扱う能力」
　の情報を取得するAPIである。ここで手に入れる情報を用いて諸々の値を決める。

・デバイスとサーフェイスの相性次第では、getSurfaceFormatsKHR(),getSurfacePresentModesKHR()
　の戻り値が空になるということがあり得るため、念のためこの2つのメソッドの戻り値が
　空でないかどうかの判定を物理デバイス選定の処理に記述した方が良い。

・3章では描画先となるイメージを自分で準備してそこに描画したが、
　スワップチェーンは自分でイメージを保持しているため、自分でイメージを手づから作成する必要はなく、
　スワップチェーンが元から保持しているイメージを取得してそこに描画することになる。

　スワップチェーンからイメージを取得した後の流れは基本的に同じである。
　イメージからイメージビューを作成、レンダーパスやパイプラインなどの作成、
　フレームバッファを作成してイメージビューと紐づけ、コマンドバッファにコマンドを積んで
　キューに送信する。

　スワップチェーンは複数のイメージを持っているので、配列の形で取得することになる。
　そのため、複数のイメージそれぞれについてイメージビューを作成しなければならない。

　vk::ImageView.formatについて、ここに指定するフォーマットは元となるイメージに
　合わせる必要があるため、スワップチェーンのイメージの場合は
　スワップチェーンを作成する時に指定したフォーマットを指定しなければならない。
　そのため、vk::SurfaceFormatKHRの値を変数に保持しておいたのである。

・finalLayoutとは、イメージのメモリ上における配置方法・取り扱い方法に関する指定である。
　「イメージレイアウト」という。いろいろな設定があり、必要に応じて最適なものを指定しなければならない。
　間違ったものを指定するとエラーが出る場合もある。

　レンダーパスの設定によって、レンダリング処理が終わった後でどのようなイメージレイアウトにするかを
　決めることができる。今回はレンダリングが終わった後で表示(プレゼン)しなければならず、
　その場合はvk::ImageLayout::ePresentSrcKHRでなければならないという決まりのため、
　今回はこれを指定している。

　3章で指定したeGeneralは一応どんな扱いを受けても基本的にはOKらしく、
　eGeneralのままでも動くには動くが、やめておいた方が無難である。

・コマンドバッファに記録するコマンドには「どのフレームバッファを使って描画するか」
　という情報が内包されている。もし固定の内容のコマンドバッファを使ってしまうと、
　毎回同じフレームバッファが使われることになる。毎回同じフレームバッファということは、
　毎回同じイメージに向けて描画することになってしまう。これではスワップチェーンによる
　表示処理が上手くいかなくなってしまう。

　そこで、舞フレームコマンドバッファをリセットして、コマンドを記録し直すことにする。
　こうすることで毎回別のイメージに向けて描画できる。
　リセットできるようにするには、コマンドプール作成時にvk::CommandPoolCreateInfo.flagsに
　vk::CommandPoolCreateFlagBits::eResetCommandBufferを指定すると、
　そのコマンドプールから作成したコマンドバッファはリセット可能になる。
　なお、リセットの方法はコマンドバッファのreset()メソッドを呼び出すだけである。

・スワップチェーンは表示する画像(イメージ)を次々に切り替えていく機構である。
　スワップチェーンを利用する側としては、「次に表示される予定のイメージ」に
　描画を行いたいわけである。

　そこで、「次に描画を行うべきイメージ」を、論理デバイスのacquireNextImageKHR()メソッドで取得する。
　スワップチェーンのイメージを配列として取得したが、その何番目のイメージという番号の形で手に入る。
　このメソッドは次に描画するべきイメージを教えてくれるだけでなく、
　「描画されても良いように準備する処理」なども含んでいるため、
　スワップチェーンのイメージに描画する前には必ず呼ぶ必要がある。
　(正確には「描画された後表示されても良いように準備する処理」の方が近い)

　acquireNextImageKHR()は直ちに描画の準備を整えてくれるわけではないため、
　少し待たないと描画の準備を完了してくれない。
　イメージのインデックスは戻り値として先に返してくれる。
　そのため、フェンスなどを利用して描画の準備が終わるまで待機する必要がある。

・イメージの表示(プレゼンテーション)もGPUの仕事である。
　GPUの仕事ということはつまり、キューにコマンドを送信することになる。

　ここでまた少し面倒なのが、どの物理デバイスのどのキューかによって、
　プレゼンテーションの機能をサポートしている場合とサポートしていない場合があり得る。
　ある物理デバイスのあるキューが、あるサーフェイスへのプレゼンテーションを行えるかどうかは、
　物理デバイスのgetSurfaceSupportKHR()メソッドで行える。

・プレゼンテーションを行うにはキューにそのコマンドを送る必要がある。
　今まではコマンドバッファにコマンドを送信していたが、この場合はプレゼンテーションではコマンドバッファは経由しない。
　プレゼンテーションのコマンドはキューに直接送信するAPIがあるため、それを使用する。
　プレゼンテーションはキューのpresentKHR()メソッドで行う。

・処理の順序に関して、守るべき処理の順序をGPUにあらかじめ教え込んでおき、
　アプリケーション側は他のことに集中した方が良い。

　現在、毎フレームやっている処理を整理すると、

1.次フレームで描画するイメージの準備
2.レンダリング
3.画面へのプレゼンテーション

　ということになる。この順番は崩せない。
　レンダリングはイメージが準備できるまでできず、プレゼンテーションはレンダリングが終わるまでできない。
　ということは、2つのセマフォを作る必要がある。

・何かしら送った命令が実行中の状態でプログラムが終了するとよくないため、
　プログラムが終了する前には1回waitIdle()を挟んでおく。

・これまで作ったものには重大な欠陥がある。
　それは、ウィンドウをリサイズするとたちまちエラーを吐いて終了してしまうことである。
　これは、描画対象(サーフェイス)の状態が変化すると、スワップチェーンが無効になってしまうためである。
　このような場合も正常に動くアプリを作るには、無効になったスワップチェーンを作り直す
　処理を実装する必要がある。

　まず、スワップチェーンが無効になったらそのことを検出する必要がある。
　これは、acquireNextImageKHR()の戻り値を見ることでわかる。
　戻り値はvk::Resultであり、正常な場合はeSuccessになるが、
　ウィンドウのリサイズのようなスワップチェーンの有効性にかかわる問題が起きた場合は
　eSuboptimalKHR, eErrorOutOfDateKHR のいずれかになる。
　それぞれの意味については以下の通り。

eSuboptimalKHR
　→ まだ正常に動作することができるが、もうスワップチェーンはサーフェイスと正しく整合した状態ではない。

eErrorOutOfDateKHR
　→ もはや完全に使えない状態になった。もう無理。

　Suboptimalの場合は必ずしも直ちに再作成する必要はないが、
　現段階では再作成してしまうことにする。
　スワップチェーンを作り直す場合、実際にはスワップチェーンに依存して作られるオブジェクト群も
　同時に作り直す必要がある。具体的にはスワップチェーンのイメージから作られるイメージビュー、
　およびイメージビューから作られるフレームバッファがその対象である。

　とりあえず、スワップチェーン及び再作成の必要があるオブジェクト群の作成処理を
　1つの関数にまとめてしまうとよい。最初の作成時もリサイズによる再作成時も
　処理は共通しているため、関数にまとめてしまえば再利用できる。
　しかし、再作成時のために破棄処理が入ることには注意する。

・以下コードについて、

auto recreateSwapchain = [&](){
    swapchainFramebufs.clear();
    swapchainImageViews.clear();
    swapchainImages.clear();
    swapchain.reset();
	
	...
	
　これは戻り値をautoで推論したラムダ式を記述している？
　[&] のところは「キャプチャ」と呼ぶらしいが、ここに&だけを指定したら
　このラムダ式以前に宣言された全ての変数の参照をこのラムダ式内で
　使用できるということなのだろうか？

　cpprefjpを確認したところ、以下のような記載があった。
https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html
　「ラムダ式からその外側の変数を使用するには、「キャプチャ(capture)」という機能を使用する。
　ラムダ式の先頭にある [ ] は「ラムダ導入子(lambda-introducer)」と呼ばれ、
　どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。
　キャプチャの方式としては、参照かコピーのいずれかを選択できる。」

void f()
{
  int x = 3;

  // この時点で見える自動変数を参照でキャプチャし、
  // 参照した変数xを書き換える
  auto f = [&] { x = 1; };

  // 個別にキャプチャ方法を指定する場合は、
  // 以下のように、&の次に変数名を指定する
  // auto f = [&x] { x = 1; };

  f(); // x == 1
}

　また、キャプチャ記法には色々あり、
　例えば[&]はその時点で見える自動変数を参照してラムダ式の中で使用することに対し、
　[=]はその時点で見える自動変数をコピーしてラムダ式の中で使用する。
　[&x]のように特定の変数のみ指定してラムダ式の中で使用することも可能。
　であれば、参照する変数を絞った方が良いのではないか？記述は面倒になるが。
　メソッド内でも事前に宣言した4つしか使用していないし、変数を指定する形で記述する。
　いや全然他の変数も使ってた。目が節穴。

・vk::Resultではなくvk::ResultValue？
　なぜ判定に引っかからずに強制終了してしまう？
　差分のある個所
サーフェイスと相性の悪いGPUを弾く処理が参考サイトにはなくなっている、でもこれは必要では？

https://github.com/bwasty/vulkan-tutorial-hpp/blob/master/steps/18_vertex_buffer.cpp
もしかして、例外として投げられているから普通にif文で判定できていないのでは？
このサイトのコードのように、例外をキャッチする形にすれば再作成できるのでは？
メソッドに切り分ければ実現できそうではある。だがwhile文のループをどうcontinueするか？
上記で記載しているURL先のコードのように、クラスを定義してメンバとしてレンダーパスやら
論理デバイスやら必要なオブジェクトを持つようにして、それぞれの作成処理を
メソッドで定義する形にした方がよさそう。

公式チュートリアルのC++コードを写経していく形が良いかもしれない。
https://docs.vulkan.org/tutorial/latest/03_Drawing_a_triangle/00_Setup/00_Base_code.html
・

　から

======================================================================

・環境構築

　WSLでvulkan SDK,vcpkg,CMakeを使用して学習を進める形に変更
　vulkan SDKとvcpkgはインストール済み
　なんかvulkanSDKとvcpkgのダウンロード、
　~/.bashrc, ~/.profileへの環境変数追加の記述、
　あとは参考サイトの1.4の環境構築と同じファイルを作成、
　同じ手順でやったらできた。
　なぜ実家のPCではエラーが起きたのだろうか？
　違うことと言えば、C:\VulkanSDK\1.4.321.1\Bin を
　システム環境変数に追加してることぐらいだが。

　vcpkgはvs2022に付属していたものを使用、
　vulkan SDKは公式サイトからダウンロード
　手順は2つ目のサイトを参考、include,libディレクトリパスの追加と
　vulkan1-lib のようなファイルの追加はどのライブラリを使用するにしても
　必要そうな手順なので、覚えておくと良いかもしれない。
https://docs.vulkan.org/tutorial/latest/02_Development_environment.html
https://chaosplant.tech/do/vulkan/1-4/

・以下サイトを参考に進めていく
https://chaosplant.tech/do/vulkan/